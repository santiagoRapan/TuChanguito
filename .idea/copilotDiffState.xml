<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/MainActivity.kt" />
              <option name="originalContent" value="package com.example.tuchanguito&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteScaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.tooling.preview.PreviewScreenSizes&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.tuchanguito.ui.navigation.AppNavGraph&#10;import com.example.tuchanguito.ui.navigation.Routes&#10;import com.example.tuchanguito.ui.navigation.TopLevelDest&#10;import com.example.tuchanguito.ui.theme.TuChanguitoTheme&#10;import com.example.tuchanguito.data.PreferencesManager&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import com.example.tuchanguito.ui.theme.ButtonBlue&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.core.view.WindowCompat&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteType&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.windowInsetsPadding&#10;import androidx.compose.foundation.layout.WindowInsetsSides&#10;import androidx.compose.foundation.layout.only&#10;import androidx.compose.foundation.layout.systemBars&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.material3.NavigationRail&#10;import androidx.compose.material3.NavigationRailItem&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.displayCutout&#10;import androidx.compose.ui.platform.LocalLayoutDirection&#10;import androidx.compose.ui.unit.LayoutDirection&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        WindowCompat.setDecorFitsSystemWindows(window, false)&#10;        setContent {&#10;            val prefs = PreferencesManager(this)&#10;            val theme by prefs.theme.collectAsState(initial = &quot;system&quot;)&#10;            val isDark = when(theme){&quot;dark&quot;-&gt;true;&quot;light&quot;-&gt;false;else-&gt;isSystemInDarkTheme()}&#10;            TuChanguitoTheme(darkTheme = isDark) {&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    TuChanguitoApp()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@PreviewScreenSizes&#10;@Composable&#10;fun TuChanguitoApp(modifier: Modifier = Modifier) {&#10;    val context = LocalContext.current&#10;    val prefs = remember { PreferencesManager(context) }&#10;    val authToken by prefs.authToken.collectAsState(initial = null)&#10;    val navController = rememberNavController()&#10;    var currentDestination by rememberSaveable { mutableStateOf&lt;TopLevelDest?&gt;(null) }&#10;&#10;    val isLandscape = LocalConfiguration.current.orientation == Configuration.ORIENTATION_LANDSCAPE&#10;    val layoutType = if (isLandscape) NavigationSuiteType.NavigationRail else NavigationSuiteType.NavigationBar&#10;&#10;    if (authToken.isNullOrEmpty()) {&#10;        AppNavGraph(&#10;            navController = navController,&#10;            startDestination = Routes.AUTH,&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;    } else {&#10;        // In landscape show an explicit NavigationRail on the left; in portrait keep the adaptive bottom navigation&#10;        if (isLandscape) {&#10;            // Determine layout direction to know which side is Start/End&#10;            val layoutDirection = LocalLayoutDirection.current&#10;            // If layoutDirection==LTR, Start is left; if RTL, Start is right&#10;            // We'll apply displayCutout padding on the rail side (Start)&#10;            Row(modifier = Modifier.fillMaxSize().windowInsetsPadding(WindowInsets.displayCutout.only(WindowInsetsSides.Start))) {&#10;                NavigationRail(modifier = Modifier.fillMaxHeight().windowInsetsPadding(WindowInsets.displayCutout.only(WindowInsetsSides.Start))) {&#10;                    listOf(TopLevelDest.Home, TopLevelDest.Products, TopLevelDest.Lists, TopLevelDest.Pantry, TopLevelDest.Profile).forEach { dest -&gt;&#10;                        val selected = currentDestination?.route == dest.route&#10;                        NavigationRailItem(&#10;                            selected = selected,&#10;                            onClick = {&#10;                                currentDestination = dest&#10;                                navController.navigate(dest.route) { launchSingleTop = true }&#10;                            },&#10;                            icon = { Icon(dest.icon, contentDescription = dest.label) },&#10;                            label = { Text(dest.label) }&#10;                        )&#10;                    }&#10;                }&#10;                // Content area: apply displayCutout padding on the opposite side as well to prevent overlap&#10;                val contentPadding = WindowInsets.displayCutout.only(WindowInsetsSides.End)&#10;                Box(modifier = Modifier.fillMaxSize().windowInsetsPadding(contentPadding)) {&#10;                    AppNavGraph(&#10;                        navController = navController,&#10;                        startDestination = TopLevelDest.Home.route,&#10;                        modifier = Modifier.fillMaxSize()&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            NavigationSuiteScaffold(&#10;                layoutType = layoutType,&#10;                navigationSuiteItems = {&#10;                    listOf(TopLevelDest.Home, TopLevelDest.Products, TopLevelDest.Lists, TopLevelDest.Pantry, TopLevelDest.Profile).forEach { dest -&gt;&#10;                        item(&#10;                            icon = { Icon(dest.icon, contentDescription = dest.label, tint = if (currentDestination?.route == dest.route) ButtonBlue else Color.Unspecified) },&#10;                            label = { Text(dest.label, color = if (currentDestination?.route == dest.route) ButtonBlue else Color.Unspecified) },&#10;                            selected = currentDestination?.route == dest.route,&#10;                            onClick = {&#10;                                currentDestination = dest&#10;                                navController.navigate(dest.route) { launchSingleTop = true }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            ) {&#10;                AppNavGraph(&#10;                    navController = navController,&#10;                    startDestination = TopLevelDest.Home.route,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GreetingPreview() {&#10;    TuChanguitoTheme {&#10;        TuChanguitoApp()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.tuchanguito&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteScaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.tooling.preview.PreviewScreenSizes&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.tuchanguito.ui.navigation.AppNavGraph&#10;import com.example.tuchanguito.ui.navigation.Routes&#10;import com.example.tuchanguito.ui.navigation.TopLevelDest&#10;import com.example.tuchanguito.ui.theme.TuChanguitoTheme&#10;import com.example.tuchanguito.data.PreferencesManager&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import com.example.tuchanguito.ui.theme.ButtonBlue&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.core.view.WindowCompat&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteType&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.windowInsetsPadding&#10;import androidx.compose.foundation.layout.WindowInsetsSides&#10;import androidx.compose.foundation.layout.only&#10;import androidx.compose.foundation.layout.systemBars&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.material3.NavigationRail&#10;import androidx.compose.material3.NavigationRailItem&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.displayCutout&#10;import androidx.compose.ui.platform.LocalLayoutDirection&#10;import androidx.compose.ui.unit.LayoutDirection&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.unit.dp&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        WindowCompat.setDecorFitsSystemWindows(window, false)&#10;        setContent {&#10;            val prefs = PreferencesManager(this)&#10;            val theme by prefs.theme.collectAsState(initial = &quot;system&quot;)&#10;            val isDark = when(theme){&quot;dark&quot;-&gt;true;&quot;light&quot;-&gt;false;else-&gt;isSystemInDarkTheme()}&#10;            TuChanguitoTheme(darkTheme = isDark) {&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    TuChanguitoApp()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@PreviewScreenSizes&#10;@Composable&#10;fun TuChanguitoApp(modifier: Modifier = Modifier) {&#10;    val context = LocalContext.current&#10;    val prefs = remember { PreferencesManager(context) }&#10;    val authToken by prefs.authToken.collectAsState(initial = null)&#10;    val navController = rememberNavController()&#10;    var currentDestination by rememberSaveable { mutableStateOf&lt;TopLevelDest?&gt;(null) }&#10;&#10;    val isLandscape = LocalConfiguration.current.orientation == Configuration.ORIENTATION_LANDSCAPE&#10;    val layoutType = if (isLandscape) NavigationSuiteType.NavigationRail else NavigationSuiteType.NavigationBar&#10;&#10;    if (authToken.isNullOrEmpty()) {&#10;        AppNavGraph(&#10;            navController = navController,&#10;            startDestination = Routes.AUTH,&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;    } else {&#10;        // In landscape show an explicit NavigationRail on the left; in portrait keep the adaptive bottom navigation&#10;        if (isLandscape) {&#10;            // Determine layout direction to know which side is Start/End&#10;            val layoutDirection = LocalLayoutDirection.current&#10;            // If layoutDirection==LTR, Start is left; if RTL, Start is right&#10;            // We'll apply displayCutout padding on the rail side (Start)&#10;            Row(modifier = Modifier.fillMaxSize().windowInsetsPadding(WindowInsets.displayCutout.only(WindowInsetsSides.Start))) {&#10;                NavigationRail(modifier = Modifier.fillMaxHeight().windowInsetsPadding(WindowInsets.displayCutout.only(WindowInsetsSides.Start))) {&#10;                    Column(modifier = Modifier.fillMaxHeight(), verticalArrangement = Arrangement.spacedBy(24.dp, Alignment.CenterVertically)) {&#10;                        listOf(TopLevelDest.Home, TopLevelDest.Products, TopLevelDest.Lists, TopLevelDest.Pantry, TopLevelDest.Profile).forEach { dest -&gt;&#10;                            val selected = currentDestination?.route == dest.route&#10;                            NavigationRailItem(&#10;                                selected = selected,&#10;                                onClick = {&#10;                                    currentDestination = dest&#10;                                    navController.navigate(dest.route) { launchSingleTop = true }&#10;                                },&#10;                                icon = { Icon(dest.icon, contentDescription = dest.label) },&#10;                                label = { Text(dest.label) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                // Content area: apply displayCutout padding on the opposite side as well to prevent overlap&#10;                val contentPadding = WindowInsets.displayCutout.only(WindowInsetsSides.End)&#10;                Box(modifier = Modifier.fillMaxSize().windowInsetsPadding(contentPadding)) {&#10;                    AppNavGraph(&#10;                        navController = navController,&#10;                        startDestination = TopLevelDest.Home.route,&#10;                        modifier = Modifier.fillMaxSize()&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            NavigationSuiteScaffold(&#10;                layoutType = layoutType,&#10;                navigationSuiteItems = {&#10;                    listOf(TopLevelDest.Home, TopLevelDest.Products, TopLevelDest.Lists, TopLevelDest.Pantry, TopLevelDest.Profile).forEach { dest -&gt;&#10;                        item(&#10;                            icon = { Icon(dest.icon, contentDescription = dest.label, tint = if (currentDestination?.route == dest.route) ButtonBlue else Color.Unspecified) },&#10;                            label = { Text(dest.label, color = if (currentDestination?.route == dest.route) ButtonBlue else Color.Unspecified) },&#10;                            selected = currentDestination?.route == dest.route,&#10;                            onClick = {&#10;                                currentDestination = dest&#10;                                navController.navigate(dest.route) { launchSingleTop = true }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            ) {&#10;                AppNavGraph(&#10;                    navController = navController,&#10;                    startDestination = TopLevelDest.Home.route,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GreetingPreview() {&#10;    TuChanguitoTheme {&#10;        TuChanguitoApp()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/navigation/IconsProbe.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/navigation/IconsProbe.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="// Archivo de prueba temporal para verificar disponibilidad de íconos de Material.&#10;// Ya no se utiliza y se deja intencionalmente vacío para evitar imports innecesarios." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/screens/lists/ListsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/screens/lists/ListsScreen.kt" />
              <option name="originalContent" value="package com.example.tuchanguito.ui.screens.lists&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Create&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.ui.unit.dp&#10;import com.example.tuchanguito.data.AppRepository&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ListsScreen(onOpenList: (Long) -&gt; Unit) {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val repo = remember { AppRepository.get(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val snackbarHost = remember { SnackbarHostState() }&#10;    // Load lists from API on first composition&#10;    LaunchedEffect(Unit) {&#10;        val res = repo.refreshLists()&#10;        if (res.isFailure) snackbarHost.showSnackbar(res.exceptionOrNull()?.message ?: &quot;No se pudo cargar listas&quot;)&#10;    }&#10;    val lists by repo.activeLists().collectAsState(initial = emptyList())&#10;&#10;    var showCreate by rememberSaveable { mutableStateOf(false) }&#10;    var newName by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var editId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var editName by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var busy by remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = { TopAppBar(title = { Text(&quot;Listas&quot;) }) },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHost) },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = { showCreate = true }) { Text(&quot;+&quot;) }&#10;        },&#10;        contentWindowInsets = WindowInsets.systemBars&#10;    ) { padding -&gt;&#10;        val isLandscape = LocalConfiguration.current.orientation == Configuration.ORIENTATION_LANDSCAPE&#10;        val scrollMod = if (isLandscape) Modifier.verticalScroll(rememberScrollState()) else Modifier&#10;        Column(Modifier.fillMaxSize().then(scrollMod).padding(padding).padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            lists.forEach { list -&gt;&#10;                ListItem(&#10;                    headlineContent = { Text(list.title) },&#10;                    trailingContent = {&#10;                        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                            IconButton(onClick = { editId = list.id; editName = list.title }) {&#10;                                Icon(Icons.Filled.Create, contentDescription = &quot;Renombrar&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                            }&#10;                            IconButton(onClick = {&#10;                                scope.launch {&#10;                                    busy = true&#10;                                    try {&#10;                                        repo.deleteListRemote(list.id)&#10;                                    } catch (t: Throwable) {&#10;                                        snackbarHost.showSnackbar(t.message ?: &quot;No se pudo eliminar&quot;)&#10;                                    } finally { busy = false }&#10;                                }&#10;                            }) { Icon(Icons.Filled.Delete, contentDescription = &quot;Eliminar&quot;, tint = MaterialTheme.colorScheme.error) }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth().clickable { onOpenList(list.id) }&#10;                )&#10;                Divider()&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showCreate) {&#10;        val nameTrim = newName.trim()&#10;        val duplicate = lists.any { it.title.equals(nameTrim, ignoreCase = true) }&#10;        AlertDialog(&#10;            onDismissRequest = { if (!busy) { showCreate = false; newName = &quot;&quot; } },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    scope.launch {&#10;                        busy = true&#10;                        if (duplicate) { snackbarHost.showSnackbar(&quot;Ya existe una lista con ese nombre&quot;); busy = false; return@launch }&#10;                        val id = try { repo.createList(nameTrim) } catch (t: Throwable) { snackbarHost.showSnackbar(t.message ?: &quot;No se pudo crear&quot;); 0L } finally { busy = false }&#10;                        if (id &gt; 0) { showCreate = false; val go = id; newName = &quot;&quot;; onOpenList(go) }&#10;                     }&#10;                 }, enabled = nameTrim.isNotBlank() &amp;&amp; !busy &amp;&amp; !duplicate) { Text(&quot;Crear lista&quot;) }&#10;            },&#10;            dismissButton = { TextButton(onClick = { if (!busy) { showCreate = false; newName = &quot;&quot; } }) { Text(&quot;Cancelar&quot;) } },&#10;            title = { Text(&quot;Nueva lista&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = newName,&#10;                    onValueChange = { value -&gt; newName = value },&#10;                    label = { Text(&quot;Nombre de la lista&quot;) },&#10;                    singleLine = true,&#10;                    isError = duplicate,&#10;                    supportingText = { if (duplicate) Text(&quot;Ya existe una lista con ese nombre&quot;) }&#10;                )&#10;            }&#10;        )&#10;    }&#10;&#10;    if (editId != null) {&#10;        val id = editId!!&#10;        val renameTrim = editName.trim()&#10;        val renameDuplicate = lists.any { it.id != id &amp;&amp; it.title.equals(renameTrim, ignoreCase = true) }&#10;        AlertDialog(&#10;            onDismissRequest = { if (!busy) { editId = null; editName = &quot;&quot; } },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    scope.launch {&#10;                        busy = true&#10;                        if (renameDuplicate) { snackbarHost.showSnackbar(&quot;Ya existe una lista con ese nombre&quot;); busy = false; return@launch }&#10;                        try { repo.renameList(id, renameTrim) } catch (t: Throwable) { snackbarHost.showSnackbar(t.message ?: &quot;No se pudo renombrar&quot;) } finally { busy = false }&#10;                          editId = null; editName = &quot;&quot;&#10;                     }&#10;                }, enabled = renameTrim.isNotBlank() &amp;&amp; !busy &amp;&amp; !renameDuplicate) { Text(&quot;Guardar&quot;) }&#10;            },&#10;            dismissButton = { TextButton(onClick = { if (!busy) { editId = null; editName = &quot;&quot; } }) { Text(&quot;Cancelar&quot;) } },&#10;            title = { Text(&quot;Renombrar lista&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = editName,&#10;                    onValueChange = { value -&gt; editName = value },&#10;                    label = { Text(&quot;Nuevo nombre&quot;) },&#10;                    singleLine = true,&#10;                    isError = renameDuplicate,&#10;                    supportingText = { if (renameDuplicate) Text(&quot;Ya existe una lista con ese nombre&quot;) }&#10;                )&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.tuchanguito.ui.screens.lists&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Create&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.ui.unit.dp&#10;import com.example.tuchanguito.data.AppRepository&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ListsScreen(onOpenList: (Long) -&gt; Unit) {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val repo = remember { AppRepository.get(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val snackbarHost = remember { SnackbarHostState() }&#10;    // Load lists from API on first composition&#10;    LaunchedEffect(Unit) {&#10;        val res = repo.refreshLists()&#10;        if (res.isFailure) snackbarHost.showSnackbar(res.exceptionOrNull()?.message ?: &quot;No se pudo cargar listas&quot;)&#10;    }&#10;    val lists by repo.activeLists().collectAsState(initial = emptyList())&#10;&#10;    var showCreate by rememberSaveable { mutableStateOf(false) }&#10;    var newName by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var editId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var editName by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var busy by remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = { TopAppBar(title = { Text(&quot;Listas&quot;) }) },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHost) },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = { showCreate = true }) { Icon(Icons.Filled.Add, contentDescription = &quot;Crear lista&quot;) }&#10;        },&#10;        contentWindowInsets = WindowInsets.systemBars&#10;    ) { padding -&gt;&#10;        val isLandscape = LocalConfiguration.current.orientation == Configuration.ORIENTATION_LANDSCAPE&#10;        val scrollMod = if (isLandscape) Modifier.verticalScroll(rememberScrollState()) else Modifier&#10;        Column(Modifier.fillMaxSize().then(scrollMod).padding(padding).padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            lists.forEach { list -&gt;&#10;                ListItem(&#10;                    headlineContent = { Text(list.title) },&#10;                    trailingContent = {&#10;                        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                            IconButton(onClick = { editId = list.id; editName = list.title }) {&#10;                                Icon(Icons.Filled.Create, contentDescription = &quot;Renombrar&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                            }&#10;                            IconButton(onClick = {&#10;                                scope.launch {&#10;                                    busy = true&#10;                                    try {&#10;                                        repo.deleteListRemote(list.id)&#10;                                    } catch (t: Throwable) {&#10;                                        snackbarHost.showSnackbar(t.message ?: &quot;No se pudo eliminar&quot;)&#10;                                    } finally { busy = false }&#10;                                }&#10;                            }) { Icon(Icons.Filled.Delete, contentDescription = &quot;Eliminar&quot;, tint = MaterialTheme.colorScheme.error) }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth().clickable { onOpenList(list.id) }&#10;                )&#10;                Divider()&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showCreate) {&#10;        val nameTrim = newName.trim()&#10;        val duplicate = lists.any { it.title.equals(nameTrim, ignoreCase = true) }&#10;        AlertDialog(&#10;            onDismissRequest = { if (!busy) { showCreate = false; newName = &quot;&quot; } },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    scope.launch {&#10;                        busy = true&#10;                        if (duplicate) { snackbarHost.showSnackbar(&quot;Ya existe una lista con ese nombre&quot;); busy = false; return@launch }&#10;                        val id = try { repo.createList(nameTrim) } catch (t: Throwable) { snackbarHost.showSnackbar(t.message ?: &quot;No se pudo crear&quot;); 0L } finally { busy = false }&#10;                        if (id &gt; 0) { showCreate = false; val go = id; newName = &quot;&quot;; onOpenList(go) }&#10;                     }&#10;                 }, enabled = nameTrim.isNotBlank() &amp;&amp; !busy &amp;&amp; !duplicate) { Text(&quot;Crear lista&quot;) }&#10;            },&#10;            dismissButton = { TextButton(onClick = { if (!busy) { showCreate = false; newName = &quot;&quot; } }) { Text(&quot;Cancelar&quot;) } },&#10;            title = { Text(&quot;Nueva lista&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = newName,&#10;                    onValueChange = { value -&gt; newName = value },&#10;                    label = { Text(&quot;Nombre de la lista&quot;) },&#10;                    singleLine = true,&#10;                    isError = duplicate,&#10;                    supportingText = { if (duplicate) Text(&quot;Ya existe una lista con ese nombre&quot;) }&#10;                )&#10;            }&#10;        )&#10;    }&#10;&#10;    if (editId != null) {&#10;        val id = editId!!&#10;        val renameTrim = editName.trim()&#10;        val renameDuplicate = lists.any { it.id != id &amp;&amp; it.title.equals(renameTrim, ignoreCase = true) }&#10;        AlertDialog(&#10;            onDismissRequest = { if (!busy) { editId = null; editName = &quot;&quot; } },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    scope.launch {&#10;                        busy = true&#10;                        if (renameDuplicate) { snackbarHost.showSnackbar(&quot;Ya existe una lista con ese nombre&quot;); busy = false; return@launch }&#10;                        try { repo.renameList(id, renameTrim) } catch (t: Throwable) { snackbarHost.showSnackbar(t.message ?: &quot;No se pudo renombrar&quot;) } finally { busy = false }&#10;                          editId = null; editName = &quot;&quot;&#10;                     }&#10;                }, enabled = renameTrim.isNotBlank() &amp;&amp; !busy &amp;&amp; !renameDuplicate) { Text(&quot;Guardar&quot;) }&#10;            },&#10;            dismissButton = { TextButton(onClick = { if (!busy) { editId = null; editName = &quot;&quot; } }) { Text(&quot;Cancelar&quot;) } },&#10;            title = { Text(&quot;Renombrar lista&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = editName,&#10;                    onValueChange = { value -&gt; editName = value },&#10;                    label = { Text(&quot;Nuevo nombre&quot;) },&#10;                    singleLine = true,&#10;                    isError = renameDuplicate,&#10;                    supportingText = { if (renameDuplicate) Text(&quot;Ya existe una lista con ese nombre&quot;) }&#10;                )&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>