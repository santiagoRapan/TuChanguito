<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/data/AppRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/data/AppRepository.kt" />
              <option name="originalContent" value="package com.example.tuchanguito.data&#10;&#10;import android.content.Context&#10;import com.example.tuchanguito.data.db.AppDatabase&#10;import com.example.tuchanguito.data.model.*&#10;import com.example.tuchanguito.network.ApiModule&#10;import com.example.tuchanguito.network.dto.CredentialsDTO&#10;import com.example.tuchanguito.network.dto.RegistrationDataDTO&#10;import com.example.tuchanguito.network.dto.CategoryDTO&#10;import com.example.tuchanguito.network.dto.ProductDTO&#10;import com.example.tuchanguito.network.dto.ProductRegistrationDTO&#10;import com.example.tuchanguito.network.dto.IdRef&#10;import com.example.tuchanguito.network.dto.ListItemDTO&#10;import com.example.tuchanguito.network.dto.PantryItemDTO&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import retrofit2.HttpException // Added for HTTP status inspection&#10;&#10;/**&#10; * Simple repository coordinating Room DAOs for the app features.&#10; */&#10;class AppRepository private constructor(context: Context){&#10;    private val db = AppDatabase.get(context)&#10;    private val userDao = db.userDao()&#10;    private val productDao = db.productDao()&#10;    private val categoryDao = db.categoryDao()&#10;    private val listDao = db.shoppingListDao()&#10;    private val itemDao = db.listItemDao()&#10;    private val pantryDao = db.pantryDao()&#10;    private val api = ApiModule(context)&#10;    private val prefs = PreferencesManager(context)&#10;&#10;    // Cache en memoria del pantry id activo para evitar sondas repetidas&#10;    private var cachedPantryId: Long? = null&#10;&#10;    // In-memory source of truth for lists fetched from API&#10;    private val _remoteLists = MutableStateFlow&lt;List&lt;ShoppingList&gt;&gt;(emptyList())&#10;    val remoteLists = _remoteLists.asStateFlow()&#10;&#10;    // Mutex for serializing pantry.getItems() calls&#10;    private val pantryGetMutex = Mutex()&#10;&#10;    // Auth (local)&#10;    suspend fun register(email: String, password: String, displayName: String): Result&lt;Unit&gt; = try {&#10;        // Remote first (adjust names/surnames as needed)&#10;        val names = displayName.split(&quot; &quot;)&#10;        val name = names.firstOrNull() ?: displayName&#10;        val surname = names.drop(1).joinToString(&quot; &quot;)&#10;        api.auth.register(RegistrationDataDTO(email = email, name = name, surname = surname, password = password))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun verifyAccount(email: String, code: String): Result&lt;Unit&gt; = try {&#10;        api.auth.verify(com.example.tuchanguito.network.dto.VerificationCodeDTO(code))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        val friendly = when (t) {&#10;            is retrofit2.HttpException -&gt; when (t.code()) {&#10;                400 -&gt; &quot;Código inválido&quot;&#10;                else -&gt; &quot;Error al verificar (HTTP ${t.code()})&quot;&#10;            }&#10;            else -&gt; &quot;Error al verificar&quot;&#10;        }&#10;        Result.failure(IllegalStateException(friendly, t))&#10;    }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;Unit&gt; = try {&#10;        val token = api.auth.login(CredentialsDTO(email, password)).token&#10;        prefs.setAuthToken(token)&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        // Map 401 Unauthorized to a friendly message for unregistered accounts or bad credentials&#10;        val friendlyMessage = when (t) {&#10;            is HttpException -&gt; when (t.code()) {&#10;                401 -&gt; &quot;Cuenta no registrada&quot;&#10;                else -&gt; &quot;Error de inicio de sesión (HTTP ${t.code()})&quot;&#10;            }&#10;            else -&gt; &quot;Error de inicio de sesión&quot;&#10;        }&#10;        Result.failure(IllegalStateException(friendlyMessage, t))&#10;    }&#10;&#10;    suspend fun changePassword(old: String, new: String): Result&lt;Unit&gt; = try {&#10;        api.auth.changePassword(com.example.tuchanguito.network.dto.PasswordChangeDTO(currentPassword = old, newPassword = new))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Profile&#10;    suspend fun getProfile(): Result&lt;com.example.tuchanguito.network.dto.UserDTO&gt; = try {&#10;        val user = api.auth.getProfile()&#10;        // store current user id&#10;        prefs.setCurrentUserId(user.id)&#10;        Result.success(user)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun updateProfile(name: String?, surname: String?): Result&lt;com.example.tuchanguito.network.dto.UserDTO&gt; = try {&#10;        val updated = api.auth.updateProfile(com.example.tuchanguito.network.dto.UserUpdateDTO(name = name, surname = surname))&#10;        prefs.setCurrentUserId(updated.id)&#10;        Result.success(updated)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Products&#10;    fun categories(): Flow&lt;List&lt;Category&gt;&gt; = categoryDao.observeAll()&#10;    fun products(): Flow&lt;List&lt;Product&gt;&gt; = productDao.observeAll()&#10;    suspend fun upsertCategory(name: String) = categoryDao.upsert(Category(name = name))&#10;    suspend fun upsertProduct(product: Product) = productDao.upsert(product)&#10;    suspend fun deleteProduct(product: Product) = productDao.delete(product)&#10;&#10;    // Catalog sync with API&#10;    suspend fun syncCatalog(): Result&lt;Unit&gt; = try {&#10;        // Clear local snapshot before re-hydrating to avoid ghost data after API switch&#10;        categoryDao.clearAll()&#10;        productDao.clearAll()&#10;        // Categories&#10;        val catPage = api.catalog.getCategories(page = 1, perPage = 1000)&#10;        catPage.data.forEach { c -&gt;&#10;            categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name))&#10;        }&#10;        // Products&#10;        val prodPage = api.catalog.getProducts(page = 1, perPage = 1000)&#10;        prodPage.data.forEach { p -&gt;&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unit = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val catId = p.category?.id&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unit))&#10;        }&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun createOrFindCategoryByName(name: String): Long {&#10;        val trimmed = name.trim()&#10;        // Try remote search&#10;        val found = runCatching { api.catalog.getCategories(name = trimmed, page = 1, perPage = 1) }.getOrNull()&#10;        val existing = found?.data?.firstOrNull { it.name.equals(trimmed, ignoreCase = true) }&#10;        if (existing != null) {&#10;            categoryDao.upsert(Category(id = existing.id ?: 0L, name = existing.name))&#10;            return existing.id ?: 0L&#10;        }&#10;        // Create&#10;        val created = api.catalog.createCategory(CategoryDTO(name = trimmed))&#10;        categoryDao.upsert(Category(id = created.id ?: 0L, name = created.name))&#10;        return created.id ?: 0L&#10;    }&#10;&#10;    suspend fun createProductRemote(name: String, price: Double, unit: String, categoryId: Long?): Long {&#10;        // Resolve category: if id came from local DB but doesn’t exist remotely, create it first&#10;        val finalCatId = if (categoryId != null) {&#10;            // Try to fetch remote category; if missing, create by local name fallback&#10;            val remoteOk = runCatching { api.catalog.getCategories(page = 1, perPage = 1000) }.getOrNull()?.data?.any { it.id == categoryId } == true&#10;            if (remoteOk) categoryId else {&#10;                // Try to read local name and recreate remotely&#10;                val localName = runCatching { categoryDao.getById(categoryId)?.name }.getOrNull()&#10;                if (!localName.isNullOrBlank()) createOrFindCategoryByName(localName) else categoryId&#10;            }&#10;        } else null&#10;&#10;        val resp = api.catalog.createProduct(&#10;            ProductRegistrationDTO(&#10;                name = name,&#10;                category = finalCatId?.let { IdRef(it) },&#10;                metadata = mapOf(&quot;price&quot; to price, &quot;unit&quot; to unit)&#10;            )&#10;        )&#10;        if (!resp.isSuccessful) {&#10;            // Attempt to find existing product with same name (409 Conflict case)&#10;            val page = runCatching { api.catalog.getProducts(name = name, page = 1, perPage = 1) }.getOrNull()&#10;            val existing = page?.data?.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;            if (existing != null) {&#10;                val exId = existing.id ?: 0L&#10;                val pPrice = (existing.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;                val pUnit = (existing.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;                productDao.upsert(Product(id = exId, name = existing.name, price = pPrice, categoryId = existing.category?.id, unit = pUnit))&#10;                return exId&#10;            }&#10;            throw IllegalStateException(&quot;Error creando producto: HTTP ${'$'}{resp.code()}&quot;)&#10;        }&#10;        // Some servers return minimal/empty body on create; fetch by name to locate the created product&#10;        val page = runCatching { api.catalog.getProducts(name = name, page = 1, perPage = 1) }.getOrNull()&#10;        val dto = page?.data?.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;            ?: throw IllegalStateException(&quot;Producto creado pero no encontrado por nombre&quot;)&#10;        val pId = dto.id ?: 0L&#10;        val pCatId = dto.category?.id&#10;        val pPrice = (dto.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;        val pUnit = (dto.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;        productDao.upsert(Product(id = pId, name = dto.name, price = pPrice, categoryId = pCatId, unit = pUnit))&#10;        // Ensure list shows all current remote products&#10;        syncProducts()&#10;        return pId&#10;    }&#10;&#10;    suspend fun updateProductRemote(id: Long, name: String, price: Double, unit: String, categoryId: Long?) {&#10;        val resp = api.catalog.updateProduct(&#10;            id,&#10;            ProductRegistrationDTO(&#10;                name = name,&#10;                category = categoryId?.let { IdRef(it) },&#10;                metadata = mapOf(&quot;price&quot; to price, &quot;unit&quot; to unit)&#10;            )&#10;        )&#10;        if (!resp.isSuccessful) {&#10;            throw IllegalStateException(&quot;Error actualizando producto: HTTP ${'$'}{resp.code()}&quot;)&#10;        }&#10;        // Regardless of body, fetch latest from server to ensure final state matches backend rules&#10;        val server = runCatching { api.catalog.getProduct(id) }.getOrNull()&#10;        val pCatId = server?.category?.id ?: categoryId&#10;        val pPrice = (server?.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;        val pUnit = (server?.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;        val pName = server?.name ?: name&#10;        productDao.upsert(Product(id = id, name = pName, price = pPrice, categoryId = pCatId, unit = pUnit))&#10;        // Refresh full list to avoid partial state&#10;        syncProducts()&#10;    }&#10;&#10;    suspend fun deleteProductRemote(id: Long) {&#10;        api.catalog.deleteProduct(id)&#10;        productDao.getById(id)?.let { productDao.delete(it) }&#10;        // Refresh remote to ensure local matches server after deletion&#10;        syncProducts()&#10;    }&#10;&#10;    private suspend fun syncProducts() {&#10;        runCatching { api.catalog.getProducts(page = 1, perPage = 1000) }&#10;            .onSuccess { page -&gt;&#10;                page.data.forEach { p -&gt;&#10;                    val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;                    val unit = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                    val catId = p.category?.id&#10;                    productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unit))&#10;                }&#10;            }&#10;    }&#10;&#10;    // Lists (API-backed)&#10;    fun activeLists(): Flow&lt;List&lt;ShoppingList&gt;&gt; = remoteLists&#10;    fun listById(id: Long): Flow&lt;ShoppingList?&gt; = listDao.observeById(id)&#10;    suspend fun loadListIntoLocal(id: Long) {&#10;        // Fetch remote list and persist into Room so UI detail observes correct title&#10;        runCatching { api.shopping.getList(id) }&#10;            .onSuccess { dto -&gt; listDao.upsert(ShoppingList(id = dto.id, title = dto.name)) }&#10;    }&#10;&#10;    suspend fun refreshLists(): Result&lt;Unit&gt; = try {&#10;        val page = api.shopping.getLists()&#10;        val lists = page.data.map { ShoppingList(id = it.id, title = it.name) }&#10;        _remoteLists.value = lists&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        // Keep previous cache and report failure without throwing&#10;        Result.failure(t)&#10;    }&#10;&#10;    private suspend fun existsListWithName(name: String): Boolean {&#10;        return try {&#10;            // Ask API filtering by name and owner=true to check uniqueness on server&#10;            val page = api.shopping.getLists(name = name, owner = true, page = 1, perPage = 1)&#10;            page.data.any { it.name.equals(name, ignoreCase = true) }&#10;        } catch (_: Throwable) { false }&#10;    }&#10;&#10;    suspend fun createList(title: String): Long {&#10;        // API requires name, description (string) and recurring (boolean)&#10;        // Prevent 409 UNIQUE constraint by checking server-side duplicates first&#10;        if (existsListWithName(title)) throw IllegalStateException(&quot;Ya existe una lista con ese nombre&quot;)&#10;        val dto = api.shopping.createList(&#10;            com.example.tuchanguito.network.dto.ShoppingListCreateDTO(&#10;                name = title,&#10;                description = &quot;&quot;,&#10;                recurring = false,&#10;                metadata = emptyMap()&#10;            )&#10;        )&#10;        // Fetch server version to ensure fields are in sync, then update cache&#10;        val created = runCatching { api.shopping.getList(dto.id) }.getOrNull()&#10;        val model = if (created != null) ShoppingList(id = created.id, title = created.name) else ShoppingList(id = dto.id, title = dto.name)&#10;        _remoteLists.update { it + model }&#10;        // Also persist in Room so ListDetail observes the correct title immediately&#10;        listDao.upsert(model)&#10;        return dto.id&#10;    }&#10;&#10;    suspend fun renameList(id: Long, newTitle: String) {&#10;        if (existsListWithName(newTitle)) throw IllegalStateException(&quot;Ya existe una lista con ese nombre&quot;)&#10;        api.shopping.updateList(id, com.example.tuchanguito.network.dto.ShoppingListCreateDTO(name = newTitle))&#10;        _remoteLists.update { cur -&gt; cur.map { if (it.id == id) it.copy(title = newTitle) else it } }&#10;        // Keep Room in sync so ListDetail shows the updated title&#10;        listDao.upsert(ShoppingList(id = id, title = newTitle))&#10;    }&#10;&#10;    suspend fun deleteListRemote(id: Long) {&#10;        api.shopping.deleteList(id)&#10;        _remoteLists.update { cur -&gt; cur.filterNot { it.id == id } }&#10;    }&#10;&#10;    fun itemsForList(listId: Long): Flow&lt;List&lt;ListItem&gt;&gt; = itemDao.observeForList(listId)&#10;&#10;    private suspend fun fetchListItemsEither(listId: Long): List&lt;ListItemDTO&gt; {&#10;        // Try plain array first&#10;        return runCatching { api.shopping.getItems(listId) }.getOrElse {&#10;            // Fallback to page-wrapped structure&#10;            runCatching { api.shopping.getItemsPage(listId).data }.getOrElse { emptyList() }&#10;        }&#10;    }&#10;&#10;    suspend fun fetchListItemsRemote(listId: Long): List&lt;ListItemDTO&gt; = fetchListItemsEither(listId)&#10;&#10;    // --- New: API-backed list item operations ---&#10;    suspend fun syncListItems(listId: Long) {&#10;        // Ensure list exists locally (FK for list_items)&#10;        runCatching { api.shopping.getList(listId) }.onSuccess { dto -&gt;&#10;            listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;        }&#10;        val remoteItems = fetchListItemsEither(listId)&#10;        remoteItems.forEach { li -&gt;&#10;            val p = li.product&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val existing = runCatching { productDao.getById(p.id ?: 0L) }.getOrNull()&#10;            var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;            var finalCatId = p.category?.id ?: existing?.categoryId&#10;            // Hydrate missing category/unit from product endpoint when needed&#10;            if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;                runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                    finalCatId = full.category?.id ?: finalCatId&#10;                    val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                    if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                }&#10;            }&#10;            p.category?.let { categoryDto -&gt;&#10;                categoryDao.upsert(Category(id = categoryDto.id ?: 0L, name = categoryDto.name))&#10;            }&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;            itemDao.upsert(&#10;                ListItem(&#10;                    id = li.id,&#10;                    listId = listId,&#10;                    productId = p.id ?: 0L,&#10;                    quantity = li.quantity.toInt(),&#10;                    acquired = li.purchased&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    suspend fun addItemRemote(listId: Long, productId: Long, quantity: Int = 1, unit: String = &quot;u&quot;): Long {&#10;        return try {&#10;            val resp = api.shopping.addItem(listId, com.example.tuchanguito.network.dto.ListItemCreateDTO(product = IdRef(productId), quantity = quantity.toDouble(), unit = unit))&#10;            if (!resp.isSuccessful) throw retrofit2.HttpException(resp)&#10;            runCatching { api.shopping.getList(listId) }.onSuccess { dto -&gt;&#10;                listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;            }&#10;            val remoteItems = fetchListItemsEither(listId)&#10;            remoteItems.forEach { li -&gt;&#10;                val p = li.product&#10;                val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;                val unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                val existing = runCatching { productDao.getById(p.id ?: 0L) }.getOrNull()&#10;                var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;                var finalCatId = p.category?.id ?: existing?.categoryId&#10;                if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;                    runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                        finalCatId = full.category?.id ?: finalCatId&#10;                        val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                        if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                    }&#10;                }&#10;                p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;                productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;                itemDao.upsert(ListItem(id = li.id, listId = listId, productId = p.id ?: 0L, quantity = li.quantity.toInt(), acquired = li.purchased))&#10;            }&#10;            remoteItems.firstOrNull { it.product.id == productId }?.id&#10;                ?: remoteItems.maxByOrNull { it.id }?.id&#10;                ?: 0L&#10;        } catch (t: Throwable) {&#10;            val code = (t as? retrofit2.HttpException)?.code()&#10;            if (code == 409) {&#10;                val remoteItems = runCatching { fetchListItemsEither(listId) }.getOrDefault(emptyList())&#10;                val existing = remoteItems.firstOrNull { it.product.id == productId }&#10;                if (existing != null) {&#10;                    val newQty = existing.quantity.toInt() + quantity&#10;                    val chosenUnit = existing.unit.ifBlank { unit }&#10;                    updateItemQuantityRemote(listId, existing.id, productId, newQty, chosenUnit)&#10;                    existing.id&#10;                } else {&#10;                    throw t&#10;                }&#10;            } else {&#10;                throw t&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun updateItemQuantityRemote(listId: Long, itemId: Long, productId: Long, newQuantity: Int, unit: String = &quot;u&quot;) {&#10;        val updated = api.shopping.updateItem(listId, itemId, com.example.tuchanguito.network.dto.ListItemCreateDTO(product = IdRef(productId), quantity = newQuantity.toDouble(), unit = unit))&#10;        val p = updated.product&#10;        val existing = runCatching { productDao.getById(p.id ?: productId) }.getOrNull()&#10;        var price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: (existing?.price ?: 0.0)&#10;        var unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        var finalUnit = unitFromServer.ifBlank { existing?.unit ?: unit }&#10;        var finalCatId = p.category?.id ?: existing?.categoryId&#10;        if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;            runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                finalCatId = full.category?.id ?: finalCatId&#10;                val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                val pr = (full.metadata?.get(&quot;price&quot;) as? Number)?.toDouble()&#10;                if (pr != null) price = pr&#10;            }&#10;        }&#10;        p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        productDao.upsert(Product(id = p.id ?: productId, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;        itemDao.upsert(&#10;            ListItem(&#10;                id = updated.id,&#10;                listId = listId,&#10;                productId = updated.product.id ?: productId,&#10;                quantity = updated.quantity.toInt(),&#10;                acquired = updated.purchased&#10;            )&#10;        )&#10;    }&#10;&#10;    suspend fun toggleItemPurchasedRemote(listId: Long, itemId: Long, purchased: Boolean) {&#10;        val updated = api.shoppingPatch.togglePurchased(listId, itemId, mapOf(&quot;purchased&quot; to purchased))&#10;        val p = updated.product&#10;        val pId = p.id ?: 0L&#10;        val existing = runCatching { productDao.getById(pId) }.getOrNull()&#10;        var price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: (existing?.price ?: 0.0)&#10;        var unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;        var finalCatId = p.category?.id ?: existing?.categoryId&#10;        if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;            runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                finalCatId = full.category?.id ?: finalCatId&#10;                val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                val pr = (full.metadata?.get(&quot;price&quot;) as? Number)?.toDouble()&#10;                if (pr != null) price = pr&#10;            }&#10;        }&#10;        p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        productDao.upsert(Product(id = pId, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;        itemDao.upsert(ListItem(id = updated.id, listId = listId, productId = pId, quantity = updated.quantity.toInt(), acquired = updated.purchased))&#10;    }&#10;&#10;    suspend fun deleteItemRemote(listId: Long, itemId: Long, local: ListItem? = null) {&#10;        // Delete from server; ignore body&#10;        runCatching { api.shopping.deleteItem(listId, itemId) }&#10;            .onFailure { throw it }&#10;        // Remove local row by id (or provided entity) to keep Room in sync immediately&#10;        if (local != null) {&#10;            runCatching { itemDao.delete(local) }&#10;        }&#10;        runCatching { itemDao.deleteById(itemId) }&#10;        // Optionally refresh items from server to ensure correct state (quantities of other items may change)&#10;        runCatching { syncListItems(listId) }&#10;    }&#10;&#10;    suspend fun deleteItemByIdLocal(id: Long) = itemDao.deleteById(id)&#10;&#10;    // Local-only fallbacks preserved&#10;    suspend fun addItem(listId: Long, productId: Long, quantity: Int = 1) = itemDao.upsert(ListItem(listId = listId, productId = productId, quantity = quantity))&#10;    suspend fun updateItem(item: ListItem) = itemDao.update(item)&#10;    suspend fun removeItem(item: ListItem) = itemDao.delete(item)&#10;&#10;    // Pantry&#10;    fun pantry(): Flow&lt;List&lt;PantryItem&gt;&gt; = pantryDao.observeAll()&#10;&#10;    private suspend fun isPantryUsable(id: Long): Boolean {&#10;        return runCatching {&#10;            api.pantry.getItems(id, page = 1, perPage = 1)&#10;            true&#10;        }.getOrDefault(false)&#10;    }&#10;&#10;    suspend fun ensureDefaultPantryId(): Long {&#10;        // Evitar llamadas repetidas: si tenemos cache en memoria, devolverla&#10;        cachedPantryId?.let { return it }&#10;        // Intentar recuperar la última alacena usada sin sondear el endpoint de items&#10;        val saved = runCatching { prefs.currentPantryId.first() }.getOrNull()&#10;        if (saved != null) {&#10;            cachedPantryId = saved&#10;            return saved&#10;        }&#10;        // No hay guardada: crear una nueva alacena inmediatamente (evitamos escanear y sondear)&#10;        val created = runCatching { api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena&quot;)) }&#10;            .getOrElse {&#10;                // Nombre alternativo para evitar conflicto si ya existe&#10;                api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena ${System.currentTimeMillis() % 10000}&quot;))&#10;            }&#10;        runCatching { prefs.setCurrentPantryId(created.id) }&#10;        cachedPantryId = created.id&#10;        return created.id&#10;    }&#10;&#10;    private suspend fun createFreshPantry(): Long {&#10;        // Try default name; if conflict, suffix with timestamp fragment&#10;        val tryNames = listOf(&quot;Alacena&quot;, &quot;Alacena ${System.currentTimeMillis() % 10000}&quot;)&#10;        for (n in tryNames) {&#10;            val created = runCatching { api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = n)) }.getOrNull()&#10;            if (created != null) return created.id&#10;        }&#10;        // Last resort&#10;        val fallback = api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena ${System.currentTimeMillis()}&quot;))&#10;        return fallback.id&#10;    }&#10;&#10;    suspend fun syncPantry(search: String? = null, categoryId: Long? = null) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        suspend fun attempt() = runCatching {&#10;            pantryGetMutex.withLock {&#10;                api.pantry.getItems(&#10;                    pantryId,&#10;                    search = search,&#10;                    categoryId = categoryId,&#10;                    page = 1,&#10;                    perPage = 1000,&#10;                    sortBy = &quot;productName&quot;,&#10;                    order = &quot;DESC&quot;&#10;                )&#10;            }&#10;        }.getOrNull()&#10;        var page = attempt()&#10;        if (page == null) {&#10;            // brief retry for transient DB/savepoint issues&#10;            delay(200)&#10;            page = attempt()&#10;        }&#10;        if (page == null) return&#10;        val items = page.data&#10;        runCatching { pantryDao.clearAll() }&#10;        items.forEach { it -&gt;&#10;            val p = it.product&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unitMeta = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val catId = p.category?.id&#10;            p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unitMeta))&#10;            pantryDao.upsert(PantryItem(id = it.id, productId = p.id ?: 0L, quantity = it.quantity.toInt()))&#10;        }&#10;    }&#10;&#10;    // --- Pantry helpers for backend-driven filtering ---&#10;    suspend fun pantryCategoriesForQuery(name: String?): List&lt;com.example.tuchanguito.network.dto.CategoryDTO&gt; {&#10;        val pantryId = ensureDefaultPantryId()&#10;        val remote = runCatching {&#10;            pantryGetMutex.withLock {&#10;                api.pantry.getItems(&#10;                    pantryId,&#10;                    search = name?.takeIf { it.isNotBlank() },&#10;                    categoryId = null,&#10;                    page = 1,&#10;                    perPage = 1000,&#10;                    sortBy = &quot;productName&quot;,&#10;                    order = &quot;ASC&quot;&#10;                )&#10;            }&#10;        }.getOrNull()&#10;        if (remote != null) {&#10;            val distinct = LinkedHashMap&lt;Long, com.example.tuchanguito.network.dto.CategoryDTO&gt;()&#10;            remote.data.forEach { it -&gt;&#10;                val c = it.product.category&#10;                val id = c?.id&#10;                if (id != null &amp;&amp; !distinct.containsKey(id)) {&#10;                    distinct[id] = com.example.tuchanguito.network.dto.CategoryDTO(id = id, name = c.name, metadata = c.metadata)&#10;                }&#10;            }&#10;            return distinct.values.toList().sortedBy { it.name.lowercase() }&#10;        }&#10;        // Fallback: derive from local snapshot to keep chips visible on API errors&#10;        val q = name?.trim()?.lowercase().orEmpty()&#10;        val localItems = runCatching { pantryDao.observeAll().first() }.getOrDefault(emptyList())&#10;        val localProducts = runCatching { productDao.observeAll().first() }.getOrDefault(emptyList())&#10;        val localCategories = runCatching { categoryDao.observeAll().first() }.getOrDefault(emptyList())&#10;        val productById = localProducts.associateBy { it.id }&#10;        val categoryById = localCategories.associateBy { it.id }&#10;        val ids = LinkedHashSet&lt;Long&gt;()&#10;        localItems.forEach { pi -&gt;&#10;            val p = productById[pi.productId]&#10;            val matches = q.isBlank() || (p?.name?.lowercase()?.contains(q) == true)&#10;            if (matches) p?.categoryId?.let { ids.add(it) }&#10;        }&#10;        return ids.mapNotNull { id -&gt;&#10;            val cat = categoryById[id] ?: return@mapNotNull null&#10;            com.example.tuchanguito.network.dto.CategoryDTO(id = id, name = cat.name, metadata = emptyMap())&#10;        }.sortedBy { it.name.lowercase() }&#10;    }&#10;&#10;    suspend fun resendVerificationCode(email: String): Result&lt;Unit&gt; = try {&#10;        api.auth.sendVerification(email)&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        Result.failure(t)&#10;    }&#10;&#10;    // Validate credentials without persisting token (used to confirm current password)&#10;    suspend fun validateCredentials(email: String, password: String): Result&lt;Unit&gt; = try {&#10;        api.auth.login(CredentialsDTO(email, password))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Share a shopping list with another user by email&#10;    suspend fun shareListRemote(listId: Long, email: String) {&#10;        val dto = api.shopping.shareList(listId, com.example.tuchanguito.network.dto.ShareRequestDTO(email))&#10;        // Keep local title in sync (id/name returned is the same list)&#10;        listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;        runCatching { refreshLists() }&#10;    }&#10;&#10;    // Pantry: add or increment quantity of an item by product id&#10;    suspend fun addOrIncrementPantryItem(productId: Long, addQuantity: Int, unit: String = &quot;u&quot;) {&#10;        // Try to use local snapshot first&#10;        val existing = pantryDao.findByProduct(productId)&#10;        if (existing != null) {&#10;            updatePantryItem(existing.id, existing.quantity + addQuantity, unit)&#10;            return&#10;        }&#10;        // Not found locally: try create remotely, and on 409 fallback to update-after-sync&#10;        val pantryId = ensureDefaultPantryId()&#10;        try {&#10;            val created = api.pantry.addItem(&#10;                pantryId,&#10;                com.example.tuchanguito.network.dto.PantryItemCreateDTO(&#10;                    product = com.example.tuchanguito.network.dto.IdRef(productId),&#10;                    quantity = addQuantity.toDouble(),&#10;                    unit = unit&#10;                )&#10;            )&#10;            created.product.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;            val pPrice = (created.product.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val pUnit = (created.product.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            productDao.upsert(Product(id = created.product.id ?: productId, name = created.product.name, price = pPrice, categoryId = created.product.category?.id, unit = pUnit))&#10;            pantryDao.upsert(PantryItem(id = created.id, productId = created.product.id ?: productId, quantity = created.quantity.toInt()))&#10;        } catch (t: Throwable) {&#10;            val code = (t as? retrofit2.HttpException)?.code()&#10;            if (code == 409) {&#10;                // Exists remotely: refresh local mirror and then update by summing quantity&#10;                runCatching { syncPantry() }&#10;                val remoteExisting = pantryDao.findByProduct(productId)&#10;                if (remoteExisting != null) {&#10;                    updatePantryItem(remoteExisting.id, remoteExisting.quantity + addQuantity, unit)&#10;                } else {&#10;                    throw t&#10;                }&#10;            } else {&#10;                throw t&#10;            }&#10;        }&#10;    }&#10;&#10;    // Pantry: update quantity (and unit if provided)&#10;    suspend fun updatePantryItem(itemId: Long, quantity: Int, unit: String = &quot;u&quot;) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        val updated = api.pantry.updateItem(&#10;            pantryId,&#10;            itemId,&#10;            com.example.tuchanguito.network.dto.PantryItemUpdateDTO(quantity = quantity.toDouble(), unit = unit)&#10;        )&#10;        pantryDao.upsert(PantryItem(id = updated.id, productId = updated.product.id ?: 0L, quantity = updated.quantity.toInt()))&#10;    }&#10;&#10;    // Pantry: delete an item&#10;    suspend fun deletePantryItem(itemId: Long) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        runCatching { api.pantry.deleteItem(pantryId, itemId) }.onFailure { throw it }&#10;        runCatching { pantryDao.deleteById(itemId) }&#10;        runCatching { syncPantry() }&#10;    }&#10;&#10;    // --- Backend-driven product search helpers for ProductsScreen ---&#10;    suspend fun searchProductsDTO(name: String?, categoryId: Long?): List&lt;ProductDTO&gt; {&#10;        val page = api.catalog.getProducts(name = name?.takeIf { it.isNotBlank() }, categoryId = categoryId, page = 1, perPage = 1000)&#10;        return page.data&#10;    }&#10;&#10;    suspend fun categoriesForQuery(name: String?): List&lt;CategoryDTO&gt; {&#10;        val page = api.catalog.getProducts(name = name?.takeIf { it.isNotBlank() }, categoryId = null, page = 1, perPage = 1000)&#10;        val distinct = LinkedHashMap&lt;Long, CategoryDTO&gt;()&#10;        page.data.forEach { p -&gt;&#10;            val c = p.category&#10;            val id = c?.id&#10;            if (id != null &amp;&amp; !distinct.containsKey(id)) distinct[id] = CategoryDTO(id = id, name = c.name, metadata = c.metadata)&#10;        }&#10;        return distinct.values.toList().sortedBy { it.name.lowercase() }&#10;    }&#10;&#10;    companion object {&#10;        @Volatile private var INSTANCE: AppRepository? = null&#10;        fun get(context: Context): AppRepository = INSTANCE ?: synchronized(this) {&#10;            INSTANCE ?: AppRepository(context.applicationContext).also { INSTANCE = it }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.tuchanguito.data&#10;&#10;import android.content.Context&#10;import com.example.tuchanguito.data.db.AppDatabase&#10;import com.example.tuchanguito.data.model.*&#10;import com.example.tuchanguito.network.ApiModule&#10;import com.example.tuchanguito.network.dto.CredentialsDTO&#10;import com.example.tuchanguito.network.dto.RegistrationDataDTO&#10;import com.example.tuchanguito.network.dto.CategoryDTO&#10;import com.example.tuchanguito.network.dto.ProductDTO&#10;import com.example.tuchanguito.network.dto.ProductRegistrationDTO&#10;import com.example.tuchanguito.network.dto.IdRef&#10;import com.example.tuchanguito.network.dto.ListItemDTO&#10;import com.example.tuchanguito.network.dto.PantryItemDTO&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import retrofit2.HttpException // Added for HTTP status inspection&#10;import androidx.room.withTransaction&#10;&#10;/**&#10; * Simple repository coordinating Room DAOs for the app features.&#10; */&#10;class AppRepository private constructor(context: Context){&#10;    private val db = AppDatabase.get(context)&#10;    private val userDao = db.userDao()&#10;    private val productDao = db.productDao()&#10;    private val categoryDao = db.categoryDao()&#10;    private val listDao = db.shoppingListDao()&#10;    private val itemDao = db.listItemDao()&#10;    private val pantryDao = db.pantryDao()&#10;    private val api = ApiModule(context)&#10;    private val prefs = PreferencesManager(context)&#10;&#10;    // Cache en memoria del pantry id activo para evitar sondas repetidas&#10;    private var cachedPantryId: Long? = null&#10;&#10;    // In-memory source of truth for lists fetched from API&#10;    private val _remoteLists = MutableStateFlow&lt;List&lt;ShoppingList&gt;&gt;(emptyList())&#10;    val remoteLists = _remoteLists.asStateFlow()&#10;&#10;    // Mutex for serializing pantry.getItems() calls&#10;    private val pantryGetMutex = Mutex()&#10;&#10;    // Auth (local)&#10;    suspend fun register(email: String, password: String, displayName: String): Result&lt;Unit&gt; = try {&#10;        // Remote first (adjust names/surnames as needed)&#10;        val names = displayName.split(&quot; &quot;)&#10;        val name = names.firstOrNull() ?: displayName&#10;        val surname = names.drop(1).joinToString(&quot; &quot;)&#10;        api.auth.register(RegistrationDataDTO(email = email, name = name, surname = surname, password = password))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun verifyAccount(email: String, code: String): Result&lt;Unit&gt; = try {&#10;        api.auth.verify(com.example.tuchanguito.network.dto.VerificationCodeDTO(code))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        val friendly = when (t) {&#10;            is retrofit2.HttpException -&gt; when (t.code()) {&#10;                400 -&gt; &quot;Código inválido&quot;&#10;                else -&gt; &quot;Error al verificar (HTTP ${t.code()})&quot;&#10;            }&#10;            else -&gt; &quot;Error al verificar&quot;&#10;        }&#10;        Result.failure(IllegalStateException(friendly, t))&#10;    }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;Unit&gt; = try {&#10;        val token = api.auth.login(CredentialsDTO(email, password)).token&#10;        prefs.setAuthToken(token)&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        // Map 401 Unauthorized to a friendly message for unregistered accounts or bad credentials&#10;        val friendlyMessage = when (t) {&#10;            is HttpException -&gt; when (t.code()) {&#10;                401 -&gt; &quot;Cuenta no registrada&quot;&#10;                else -&gt; &quot;Error de inicio de sesión (HTTP ${t.code()})&quot;&#10;            }&#10;            else -&gt; &quot;Error de inicio de sesión&quot;&#10;        }&#10;        Result.failure(IllegalStateException(friendlyMessage, t))&#10;    }&#10;&#10;    suspend fun changePassword(old: String, new: String): Result&lt;Unit&gt; = try {&#10;        api.auth.changePassword(com.example.tuchanguito.network.dto.PasswordChangeDTO(currentPassword = old, newPassword = new))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Profile&#10;    suspend fun getProfile(): Result&lt;com.example.tuchanguito.network.dto.UserDTO&gt; = try {&#10;        val user = api.auth.getProfile()&#10;        // store current user id&#10;        prefs.setCurrentUserId(user.id)&#10;        Result.success(user)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun updateProfile(name: String?, surname: String?): Result&lt;com.example.tuchanguito.network.dto.UserDTO&gt; = try {&#10;        val updated = api.auth.updateProfile(com.example.tuchanguito.network.dto.UserUpdateDTO(name = name, surname = surname))&#10;        prefs.setCurrentUserId(updated.id)&#10;        Result.success(updated)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Products&#10;    fun categories(): Flow&lt;List&lt;Category&gt;&gt; = categoryDao.observeAll()&#10;    fun products(): Flow&lt;List&lt;Product&gt;&gt; = productDao.observeAll()&#10;    suspend fun upsertCategory(name: String) = categoryDao.upsert(Category(name = name))&#10;    suspend fun upsertProduct(product: Product) = productDao.upsert(product)&#10;    suspend fun deleteProduct(product: Product) = productDao.delete(product)&#10;&#10;    // Catalog sync with API&#10;    suspend fun syncCatalog(): Result&lt;Unit&gt; = try {&#10;        // Clear local snapshot before re-hydrating to avoid ghost data after API switch&#10;        categoryDao.clearAll()&#10;        productDao.clearAll()&#10;        // Categories&#10;        val catPage = api.catalog.getCategories(page = 1, perPage = 1000)&#10;        catPage.data.forEach { c -&gt;&#10;            categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name))&#10;        }&#10;        // Products&#10;        val prodPage = api.catalog.getProducts(page = 1, perPage = 1000)&#10;        prodPage.data.forEach { p -&gt;&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unit = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val catId = p.category?.id&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unit))&#10;        }&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun createOrFindCategoryByName(name: String): Long {&#10;        val trimmed = name.trim()&#10;        // Try remote search&#10;        val found = runCatching { api.catalog.getCategories(name = trimmed, page = 1, perPage = 1) }.getOrNull()&#10;        val existing = found?.data?.firstOrNull { it.name.equals(trimmed, ignoreCase = true) }&#10;        if (existing != null) {&#10;            categoryDao.upsert(Category(id = existing.id ?: 0L, name = existing.name))&#10;            return existing.id ?: 0L&#10;        }&#10;        // Create&#10;        val created = api.catalog.createCategory(CategoryDTO(name = trimmed))&#10;        categoryDao.upsert(Category(id = created.id ?: 0L, name = created.name))&#10;        return created.id ?: 0L&#10;    }&#10;&#10;    suspend fun createProductRemote(name: String, price: Double, unit: String, categoryId: Long?): Long {&#10;        // Resolve category: if id came from local DB but doesn’t exist remotely, create it first&#10;        val finalCatId = if (categoryId != null) {&#10;            // Try to fetch remote category; if missing, create by local name fallback&#10;            val remoteOk = runCatching { api.catalog.getCategories(page = 1, perPage = 1000) }.getOrNull()?.data?.any { it.id == categoryId } == true&#10;            if (remoteOk) categoryId else {&#10;                // Try to read local name and recreate remotely&#10;                val localName = runCatching { categoryDao.getById(categoryId)?.name }.getOrNull()&#10;                if (!localName.isNullOrBlank()) createOrFindCategoryByName(localName) else categoryId&#10;            }&#10;        } else null&#10;&#10;        val resp = api.catalog.createProduct(&#10;            ProductRegistrationDTO(&#10;                name = name,&#10;                category = finalCatId?.let { IdRef(it) },&#10;                metadata = mapOf(&quot;price&quot; to price, &quot;unit&quot; to unit)&#10;            )&#10;        )&#10;        if (!resp.isSuccessful) {&#10;            // Attempt to find existing product with same name (409 Conflict case)&#10;            val page = runCatching { api.catalog.getProducts(name = name, page = 1, perPage = 1) }.getOrNull()&#10;            val existing = page?.data?.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;            if (existing != null) {&#10;                val exId = existing.id ?: 0L&#10;                val pPrice = (existing.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;                val pUnit = (existing.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;                productDao.upsert(Product(id = exId, name = existing.name, price = pPrice, categoryId = existing.category?.id, unit = pUnit))&#10;                return exId&#10;            }&#10;            throw IllegalStateException(&quot;Error creando producto: HTTP ${'$'}{resp.code()}&quot;)&#10;        }&#10;        // Some servers return minimal/empty body on create; fetch by name to locate the created product&#10;        val page = runCatching { api.catalog.getProducts(name = name, page = 1, perPage = 1) }.getOrNull()&#10;        val dto = page?.data?.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;            ?: throw IllegalStateException(&quot;Producto creado pero no encontrado por nombre&quot;)&#10;        val pId = dto.id ?: 0L&#10;        val pCatId = dto.category?.id&#10;        val pPrice = (dto.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;        val pUnit = (dto.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;        productDao.upsert(Product(id = pId, name = dto.name, price = pPrice, categoryId = pCatId, unit = pUnit))&#10;        // Ensure list shows all current remote products&#10;        syncProducts()&#10;        return pId&#10;    }&#10;&#10;    suspend fun updateProductRemote(id: Long, name: String, price: Double, unit: String, categoryId: Long?) {&#10;        val resp = api.catalog.updateProduct(&#10;            id,&#10;            ProductRegistrationDTO(&#10;                name = name,&#10;                category = categoryId?.let { IdRef(it) },&#10;                metadata = mapOf(&quot;price&quot; to price, &quot;unit&quot; to unit)&#10;            )&#10;        )&#10;        if (!resp.isSuccessful) {&#10;            throw IllegalStateException(&quot;Error actualizando producto: HTTP ${'$'}{resp.code()}&quot;)&#10;        }&#10;        // Regardless of body, fetch latest from server to ensure final state matches backend rules&#10;        val server = runCatching { api.catalog.getProduct(id) }.getOrNull()&#10;        val pCatId = server?.category?.id ?: categoryId&#10;        val pPrice = (server?.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;        val pUnit = (server?.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;        val pName = server?.name ?: name&#10;        productDao.upsert(Product(id = id, name = pName, price = pPrice, categoryId = pCatId, unit = pUnit))&#10;        // Refresh full list to avoid partial state&#10;        syncProducts()&#10;    }&#10;&#10;    suspend fun deleteProductRemote(id: Long) {&#10;        api.catalog.deleteProduct(id)&#10;        productDao.getById(id)?.let { productDao.delete(it) }&#10;        // Refresh remote to ensure local matches server after deletion&#10;        syncProducts()&#10;    }&#10;&#10;    private suspend fun syncProducts() {&#10;        runCatching { api.catalog.getProducts(page = 1, perPage = 1000) }&#10;            .onSuccess { page -&gt;&#10;                page.data.forEach { p -&gt;&#10;                    val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;                    val unit = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                    val catId = p.category?.id&#10;                    productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unit))&#10;                }&#10;            }&#10;    }&#10;&#10;    // Lists (API-backed)&#10;    fun activeLists(): Flow&lt;List&lt;ShoppingList&gt;&gt; = remoteLists&#10;    fun listById(id: Long): Flow&lt;ShoppingList?&gt; = listDao.observeById(id)&#10;    suspend fun loadListIntoLocal(id: Long) {&#10;        // Fetch remote list and persist into Room so UI detail observes correct title&#10;        runCatching { api.shopping.getList(id) }&#10;            .onSuccess { dto -&gt; listDao.upsert(ShoppingList(id = dto.id, title = dto.name)) }&#10;    }&#10;&#10;    suspend fun refreshLists(): Result&lt;Unit&gt; = try {&#10;        val page = api.shopping.getLists()&#10;        val lists = page.data.map { ShoppingList(id = it.id, title = it.name) }&#10;        _remoteLists.value = lists&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        // Keep previous cache and report failure without throwing&#10;        Result.failure(t)&#10;    }&#10;&#10;    private suspend fun existsListWithName(name: String): Boolean {&#10;        return try {&#10;            // Ask API filtering by name and owner=true to check uniqueness on server&#10;            val page = api.shopping.getLists(name = name, owner = true, page = 1, perPage = 1)&#10;            page.data.any { it.name.equals(name, ignoreCase = true) }&#10;        } catch (_: Throwable) { false }&#10;    }&#10;&#10;    suspend fun createList(title: String): Long {&#10;        // API requires name, description (string) and recurring (boolean)&#10;        // Prevent 409 UNIQUE constraint by checking server-side duplicates first&#10;        if (existsListWithName(title)) throw IllegalStateException(&quot;Ya existe una lista con ese nombre&quot;)&#10;        val dto = api.shopping.createList(&#10;            com.example.tuchanguito.network.dto.ShoppingListCreateDTO(&#10;                name = title,&#10;                description = &quot;&quot;,&#10;                recurring = false,&#10;                metadata = emptyMap()&#10;            )&#10;        )&#10;        // Fetch server version to ensure fields are in sync, then update cache&#10;        val created = runCatching { api.shopping.getList(dto.id) }.getOrNull()&#10;        val model = if (created != null) ShoppingList(id = created.id, title = created.name) else ShoppingList(id = dto.id, title = dto.name)&#10;        _remoteLists.update { it + model }&#10;        // Also persist in Room so ListDetail observes the correct title immediately&#10;        listDao.upsert(model)&#10;        return dto.id&#10;    }&#10;&#10;    suspend fun renameList(id: Long, newTitle: String) {&#10;        if (existsListWithName(newTitle)) throw IllegalStateException(&quot;Ya existe una lista con ese nombre&quot;)&#10;        api.shopping.updateList(id, com.example.tuchanguito.network.dto.ShoppingListCreateDTO(name = newTitle))&#10;        _remoteLists.update { cur -&gt; cur.map { if (it.id == id) it.copy(title = newTitle) else it } }&#10;        // Keep Room in sync so ListDetail shows the updated title&#10;        listDao.upsert(ShoppingList(id = id, title = newTitle))&#10;    }&#10;&#10;    suspend fun deleteListRemote(id: Long) {&#10;        api.shopping.deleteList(id)&#10;        _remoteLists.update { cur -&gt; cur.filterNot { it.id == id } }&#10;    }&#10;&#10;    fun itemsForList(listId: Long): Flow&lt;List&lt;ListItem&gt;&gt; = itemDao.observeForList(listId)&#10;&#10;    private suspend fun fetchListItemsEither(listId: Long): List&lt;ListItemDTO&gt; {&#10;        // Try plain array first&#10;        return runCatching { api.shopping.getItems(listId) }.getOrElse {&#10;            // Fallback to page-wrapped structure&#10;            runCatching { api.shopping.getItemsPage(listId).data }.getOrElse { emptyList() }&#10;        }&#10;    }&#10;&#10;    suspend fun fetchListItemsRemote(listId: Long): List&lt;ListItemDTO&gt; = fetchListItemsEither(listId)&#10;&#10;    // --- New: API-backed list item operations ---&#10;    suspend fun syncListItems(listId: Long) {&#10;        // Ensure list exists locally (FK for list_items)&#10;        runCatching { api.shopping.getList(listId) }.onSuccess { dto -&gt;&#10;            listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;        }&#10;        val remoteItems = fetchListItemsEither(listId)&#10;        remoteItems.forEach { li -&gt;&#10;            val p = li.product&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val existing = runCatching { productDao.getById(p.id ?: 0L) }.getOrNull()&#10;            var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;            var finalCatId = p.category?.id ?: existing?.categoryId&#10;            // Hydrate missing category/unit from product endpoint when needed&#10;            if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;                runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                    finalCatId = full.category?.id ?: finalCatId&#10;                    val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                    if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                }&#10;            }&#10;            p.category?.let { categoryDto -&gt;&#10;                categoryDao.upsert(Category(id = categoryDto.id ?: 0L, name = categoryDto.name))&#10;            }&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;            itemDao.upsert(&#10;                ListItem(&#10;                    id = li.id,&#10;                    listId = listId,&#10;                    productId = p.id ?: 0L,&#10;                    quantity = li.quantity.toInt(),&#10;                    acquired = li.purchased&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    suspend fun addItemRemote(listId: Long, productId: Long, quantity: Int = 1, unit: String = &quot;u&quot;): Long {&#10;        return try {&#10;            val resp = api.shopping.addItem(listId, com.example.tuchanguito.network.dto.ListItemCreateDTO(product = IdRef(productId), quantity = quantity.toDouble(), unit = unit))&#10;            if (!resp.isSuccessful) throw retrofit2.HttpException(resp)&#10;            runCatching { api.shopping.getList(listId) }.onSuccess { dto -&gt;&#10;                listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;            }&#10;            val remoteItems = fetchListItemsEither(listId)&#10;            remoteItems.forEach { li -&gt;&#10;                val p = li.product&#10;                val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;                val unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                val existing = runCatching { productDao.getById(p.id ?: 0L) }.getOrNull()&#10;                var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;                var finalCatId = p.category?.id ?: existing?.categoryId&#10;                if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;                    runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                        finalCatId = full.category?.id ?: finalCatId&#10;                        val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                        if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                    }&#10;                }&#10;                p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;                productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;                itemDao.upsert(ListItem(id = li.id, listId = listId, productId = p.id ?: 0L, quantity = li.quantity.toInt(), acquired = li.purchased))&#10;            }&#10;            remoteItems.firstOrNull { it.product.id == productId }?.id&#10;                ?: remoteItems.maxByOrNull { it.id }?.id&#10;                ?: 0L&#10;        } catch (t: Throwable) {&#10;            val code = (t as? retrofit2.HttpException)?.code()&#10;            if (code == 409) {&#10;                val remoteItems = runCatching { fetchListItemsEither(listId) }.getOrDefault(emptyList())&#10;                val existing = remoteItems.firstOrNull { it.product.id == productId }&#10;                if (existing != null) {&#10;                    val newQty = existing.quantity.toInt() + quantity&#10;                    val chosenUnit = existing.unit.ifBlank { unit }&#10;                    updateItemQuantityRemote(listId, existing.id, productId, newQty, chosenUnit)&#10;                    existing.id&#10;                } else {&#10;                    throw t&#10;                }&#10;            } else {&#10;                throw t&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun updateItemQuantityRemote(listId: Long, itemId: Long, productId: Long, newQuantity: Int, unit: String = &quot;u&quot;) {&#10;        val updated = api.shopping.updateItem(listId, itemId, com.example.tuchanguito.network.dto.ListItemCreateDTO(product = IdRef(productId), quantity = newQuantity.toDouble(), unit = unit))&#10;        val p = updated.product&#10;        val existing = runCatching { productDao.getById(p.id ?: productId) }.getOrNull()&#10;        var price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: (existing?.price ?: 0.0)&#10;        var unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        var finalUnit = unitFromServer.ifBlank { existing?.unit ?: unit }&#10;        var finalCatId = p.category?.id ?: existing?.categoryId&#10;        if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;            runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                finalCatId = full.category?.id ?: finalCatId&#10;                val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                val pr = (full.metadata?.get(&quot;price&quot;) as? Number)?.toDouble()&#10;                if (pr != null) price = pr&#10;            }&#10;        }&#10;        p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        productDao.upsert(Product(id = p.id ?: productId, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;        itemDao.upsert(&#10;            ListItem(&#10;                id = updated.id,&#10;                listId = listId,&#10;                productId = updated.product.id ?: productId,&#10;                quantity = updated.quantity.toInt(),&#10;                acquired = updated.purchased&#10;            )&#10;        )&#10;    }&#10;&#10;    suspend fun toggleItemPurchasedRemote(listId: Long, itemId: Long, purchased: Boolean) {&#10;        val updated = api.shoppingPatch.togglePurchased(listId, itemId, mapOf(&quot;purchased&quot; to purchased))&#10;        val p = updated.product&#10;        val pId = p.id ?: 0L&#10;        val existing = runCatching { productDao.getById(pId) }.getOrNull()&#10;        var price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: (existing?.price ?: 0.0)&#10;        var unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;        var finalCatId = p.category?.id ?: existing?.categoryId&#10;        if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;            runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                finalCatId = full.category?.id ?: finalCatId&#10;                val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                val pr = (full.metadata?.get(&quot;price&quot;) as? Number)?.toDouble()&#10;                if (pr != null) price = pr&#10;            }&#10;        }&#10;        p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        productDao.upsert(Product(id = pId, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;        itemDao.upsert(ListItem(id = updated.id, listId = listId, productId = pId, quantity = updated.quantity.toInt(), acquired = updated.purchased))&#10;    }&#10;&#10;    suspend fun deleteItemRemote(listId: Long, itemId: Long, local: ListItem? = null) {&#10;        // Delete from server; ignore body&#10;        runCatching { api.shopping.deleteItem(listId, itemId) }&#10;            .onFailure { throw it }&#10;        // Remove local row by id (or provided entity) to keep Room in sync immediately&#10;        if (local != null) {&#10;            runCatching { itemDao.delete(local) }&#10;        }&#10;        runCatching { itemDao.deleteById(itemId) }&#10;        // Optionally refresh items from server to ensure correct state (quantities of other items may change)&#10;        runCatching { syncListItems(listId) }&#10;    }&#10;&#10;    suspend fun deleteItemByIdLocal(id: Long) = itemDao.deleteById(id)&#10;&#10;    // Local-only fallbacks preserved&#10;    suspend fun addItem(listId: Long, productId: Long, quantity: Int = 1) = itemDao.upsert(ListItem(listId = listId, productId = productId, quantity = quantity))&#10;    suspend fun updateItem(item: ListItem) = itemDao.update(item)&#10;    suspend fun removeItem(item: ListItem) = itemDao.delete(item)&#10;&#10;    // Pantry&#10;    fun pantry(): Flow&lt;List&lt;PantryItem&gt;&gt; = pantryDao.observeAll()&#10;&#10;    private suspend fun isPantryUsable(id: Long): Boolean {&#10;        return runCatching {&#10;            api.pantry.getItems(id, page = 1, perPage = 1)&#10;            true&#10;        }.getOrDefault(false)&#10;    }&#10;&#10;    suspend fun ensureDefaultPantryId(): Long {&#10;        // Evitar llamadas repetidas: si tenemos cache en memoria, devolverla&#10;        cachedPantryId?.let { return it }&#10;        // Intentar recuperar la última alacena usada sin sondear el endpoint de items&#10;        val saved = runCatching { prefs.currentPantryId.first() }.getOrNull()&#10;        if (saved != null) {&#10;            cachedPantryId = saved&#10;            return saved&#10;        }&#10;        // No hay guardada: crear una nueva alacena inmediatamente (evitamos escanear y sondear)&#10;        val created = runCatching { api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena&quot;)) }&#10;            .getOrElse {&#10;                // Nombre alternativo para evitar conflicto si ya existe&#10;                api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena ${System.currentTimeMillis() % 10000}&quot;))&#10;            }&#10;        runCatching { prefs.setCurrentPantryId(created.id) }&#10;        cachedPantryId = created.id&#10;        return created.id&#10;    }&#10;&#10;    private suspend fun createFreshPantry(): Long {&#10;        // Try default name; if conflict, suffix with timestamp fragment&#10;        val tryNames = listOf(&quot;Alacena&quot;, &quot;Alacena ${System.currentTimeMillis() % 10000}&quot;)&#10;        for (n in tryNames) {&#10;            val created = runCatching { api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = n)) }.getOrNull()&#10;            if (created != null) return created.id&#10;        }&#10;        // Last resort&#10;        val fallback = api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena ${System.currentTimeMillis()}&quot;))&#10;        return fallback.id&#10;    }&#10;&#10;    suspend fun syncPantry(search: String? = null, categoryId: Long? = null) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        suspend fun attempt() = runCatching {&#10;            pantryGetMutex.withLock {&#10;                api.pantry.getItems(&#10;                    pantryId,&#10;                    search = search,&#10;                    categoryId = categoryId,&#10;                    page = 1,&#10;                    perPage = 1000,&#10;                    sortBy = &quot;productName&quot;,&#10;                    order = &quot;DESC&quot;&#10;                )&#10;            }&#10;        }.getOrNull()&#10;        var page = attempt()&#10;        if (page == null) {&#10;            // brief retry for transient DB/savepoint issues&#10;            delay(200)&#10;            page = attempt()&#10;        }&#10;        if (page == null) return&#10;        val items = page.data&#10;        // Apply changes atomically to avoid emitting empty list between clear and reinsert&#10;        db.withTransaction {&#10;            pantryDao.clearAll()&#10;            items.forEach { it -&gt;&#10;                val p = it.product&#10;                val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;                val unitMeta = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                val catId = p.category?.id&#10;                p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;                productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unitMeta))&#10;                pantryDao.upsert(PantryItem(id = it.id, productId = p.id ?: 0L, quantity = it.quantity.toInt()))&#10;            }&#10;        }&#10;    }&#10;&#10;    // --- Pantry helpers for backend-driven filtering ---&#10;    suspend fun pantryCategoriesForQuery(name: String?): List&lt;com.example.tuchanguito.network.dto.CategoryDTO&gt; {&#10;        val pantryId = ensureDefaultPantryId()&#10;        val remote = runCatching {&#10;            pantryGetMutex.withLock {&#10;                api.pantry.getItems(&#10;                    pantryId,&#10;                    search = name?.takeIf { it.isNotBlank() },&#10;                    categoryId = null,&#10;                    page = 1,&#10;                    perPage = 1000,&#10;                    sortBy = &quot;productName&quot;,&#10;                    order = &quot;ASC&quot;&#10;                )&#10;            }&#10;        }.getOrNull()&#10;        if (remote != null) {&#10;            val distinct = LinkedHashMap&lt;Long, com.example.tuchanguito.network.dto.CategoryDTO&gt;()&#10;            remote.data.forEach { it -&gt;&#10;                val c = it.product.category&#10;                val id = c?.id&#10;                if (id != null &amp;&amp; !distinct.containsKey(id)) {&#10;                    distinct[id] = com.example.tuchanguito.network.dto.CategoryDTO(id = id, name = c.name, metadata = c.metadata)&#10;                }&#10;            }&#10;            return distinct.values.toList().sortedBy { it.name.lowercase() }&#10;        }&#10;        // Fallback: derive from local snapshot to keep chips visible on API errors&#10;        val q = name?.trim()?.lowercase().orEmpty()&#10;        val localItems = runCatching { pantryDao.observeAll().first() }.getOrDefault(emptyList())&#10;        val localProducts = runCatching { productDao.observeAll().first() }.getOrDefault(emptyList())&#10;        val localCategories = runCatching { categoryDao.observeAll().first() }.getOrDefault(emptyList())&#10;        val productById = localProducts.associateBy { it.id }&#10;        val categoryById = localCategories.associateBy { it.id }&#10;        val ids = LinkedHashSet&lt;Long&gt;()&#10;        localItems.forEach { pi -&gt;&#10;            val p = productById[pi.productId]&#10;            val matches = q.isBlank() || (p?.name?.lowercase()?.contains(q) == true)&#10;            if (matches) p?.categoryId?.let { ids.add(it) }&#10;        }&#10;        return ids.mapNotNull { id -&gt;&#10;            val cat = categoryById[id] ?: return@mapNotNull null&#10;            com.example.tuchanguito.network.dto.CategoryDTO(id = id, name = cat.name, metadata = emptyMap())&#10;        }.sortedBy { it.name.lowercase() }&#10;    }&#10;&#10;    suspend fun resendVerificationCode(email: String): Result&lt;Unit&gt; = try {&#10;        api.auth.sendVerification(email)&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        Result.failure(t)&#10;    }&#10;&#10;    // Validate credentials without persisting token (used to confirm current password)&#10;    suspend fun validateCredentials(email: String, password: String): Result&lt;Unit&gt; = try {&#10;        api.auth.login(CredentialsDTO(email, password))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Share a shopping list with another user by email&#10;    suspend fun shareListRemote(listId: Long, email: String) {&#10;        val dto = api.shopping.shareList(listId, com.example.tuchanguito.network.dto.ShareRequestDTO(email))&#10;        // Keep local title in sync (id/name returned is the same list)&#10;        listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;        runCatching { refreshLists() }&#10;    }&#10;&#10;    // Pantry: add or increment quantity of an item by product id&#10;    suspend fun addOrIncrementPantryItem(productId: Long, addQuantity: Int, unit: String = &quot;u&quot;) {&#10;        // Try to use local snapshot first&#10;        val existing = pantryDao.findByProduct(productId)&#10;        if (existing != null) {&#10;            updatePantryItem(existing.id, existing.quantity + addQuantity, unit)&#10;            return&#10;        }&#10;        // Not found locally: try create remotely, and on 409 fallback to update-after-sync&#10;        val pantryId = ensureDefaultPantryId()&#10;        try {&#10;            val created = api.pantry.addItem(&#10;                pantryId,&#10;                com.example.tuchanguito.network.dto.PantryItemCreateDTO(&#10;                    product = com.example.tuchanguito.network.dto.IdRef(productId),&#10;                    quantity = addQuantity.toDouble(),&#10;                    unit = unit&#10;                )&#10;            )&#10;            created.product.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;            val pPrice = (created.product.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val pUnit = (created.product.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            productDao.upsert(Product(id = created.product.id ?: productId, name = created.product.name, price = pPrice, categoryId = created.product.category?.id, unit = pUnit))&#10;            pantryDao.upsert(PantryItem(id = created.id, productId = created.product.id ?: productId, quantity = created.quantity.toInt()))&#10;        } catch (t: Throwable) {&#10;            val code = (t as? retrofit2.HttpException)?.code()&#10;            if (code == 409) {&#10;                // Exists remotely: refresh local mirror and then update by summing quantity&#10;                runCatching { syncPantry() }&#10;                val remoteExisting = pantryDao.findByProduct(productId)&#10;                if (remoteExisting != null) {&#10;                    updatePantryItem(remoteExisting.id, remoteExisting.quantity + addQuantity, unit)&#10;                } else {&#10;                    throw t&#10;                }&#10;            } else {&#10;                throw t&#10;            }&#10;        }&#10;    }&#10;&#10;    // Pantry: update quantity (and unit if provided)&#10;    suspend fun updatePantryItem(itemId: Long, quantity: Int, unit: String = &quot;u&quot;) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        val updated = api.pantry.updateItem(&#10;            pantryId,&#10;            itemId,&#10;            com.example.tuchanguito.network.dto.PantryItemUpdateDTO(quantity = quantity.toDouble(), unit = unit)&#10;        )&#10;        pantryDao.upsert(PantryItem(id = updated.id, productId = updated.product.id ?: 0L, quantity = updated.quantity.toInt()))&#10;    }&#10;&#10;    // Pantry: delete an item&#10;    suspend fun deletePantryItem(itemId: Long) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        runCatching { api.pantry.deleteItem(pantryId, itemId) }.onFailure { throw it }&#10;        runCatching { pantryDao.deleteById(itemId) }&#10;        runCatching { syncPantry() }&#10;    }&#10;&#10;    // --- Backend-driven product search helpers for ProductsScreen ---&#10;    suspend fun searchProductsDTO(name: String?, categoryId: Long?): List&lt;ProductDTO&gt; {&#10;        val page = api.catalog.getProducts(name = name?.takeIf { it.isNotBlank() }, categoryId = categoryId, page = 1, perPage = 1000)&#10;        return page.data&#10;    }&#10;&#10;    suspend fun categoriesForQuery(name: String?): List&lt;CategoryDTO&gt; {&#10;        val page = api.catalog.getProducts(name = name?.takeIf { it.isNotBlank() }, categoryId = null, page = 1, perPage = 1000)&#10;        val distinct = LinkedHashMap&lt;Long, CategoryDTO&gt;()&#10;        page.data.forEach { p -&gt;&#10;            val c = p.category&#10;            val id = c?.id&#10;            if (id != null &amp;&amp; !distinct.containsKey(id)) distinct[id] = CategoryDTO(id = id, name = c.name, metadata = c.metadata)&#10;        }&#10;        return distinct.values.toList().sortedBy { it.name.lowercase() }&#10;    }&#10;&#10;    companion object {&#10;        @Volatile private var INSTANCE: AppRepository? = null&#10;        fun get(context: Context): AppRepository = INSTANCE ?: synchronized(this) {&#10;            INSTANCE ?: AppRepository(context.applicationContext).also { INSTANCE = it }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/navigation/IconsProbe.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/navigation/IconsProbe.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="// Archivo de prueba temporal para verificar disponibilidad de íconos de Material.&#10;// Ya no se utiliza y se deja intencionalmente vacío para evitar imports innecesarios." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/screens/pantry/PantryScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/screens/pantry/PantryScreen.kt" />
              <option name="originalContent" value="package com.example.tuchanguito.ui.screens.pantry&#10;&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.dp&#10;import com.example.tuchanguito.data.AppRepository&#10;import com.example.tuchanguito.data.model.Category&#10;import com.example.tuchanguito.data.model.Product&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PantryScreen() {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val repo = remember { AppRepository.get(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val pantryItems by repo.pantry().collectAsState(initial = emptyList())&#10;    val products by repo.products().collectAsState(initial = emptyList())&#10;    val categories by repo.categories().collectAsState(initial = emptyList())&#10;&#10;    val snack = remember { SnackbarHostState() }&#10;&#10;    var query by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var selectedCategoryId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var showAdd by rememberSaveable { mutableStateOf(false) }&#10;&#10;    // Backend-driven categories for chips (stable for current search)&#10;    var chipCategories by remember { mutableStateOf&lt;List&lt;Pair&lt;Long, String&gt;&gt;&gt;(emptyList()) }&#10;&#10;    // Load categories for current search text&#10;    LaunchedEffect(query) {&#10;        val list = runCatching { repo.pantryCategoriesForQuery(query.ifBlank { null }) }.getOrDefault(emptyList())&#10;        chipCategories = list.mapNotNull { it.id?.let { id -&gt; id to it.name } }&#10;        if (selectedCategoryId != null &amp;&amp; chipCategories.none { it.first == selectedCategoryId }) {&#10;            selectedCategoryId = null&#10;        }&#10;    }&#10;&#10;    // Sync pantry items when search or selected category changes&#10;    LaunchedEffect(query, selectedCategoryId) {&#10;        runCatching { repo.syncPantry(search = query.ifBlank { null }, categoryId = selectedCategoryId) }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = { TopAppBar(title = { Text(&quot;Alacena&quot;) }) },&#10;        snackbarHost = { SnackbarHost(snack) },&#10;        floatingActionButton = { FloatingActionButton(onClick = { showAdd = true }) { Icon(Icons.Default.Add, contentDescription = null) } },&#10;        contentWindowInsets = WindowInsets.systemBars&#10;    ) { padding -&gt;&#10;        Column(Modifier.fillMaxSize().padding(padding).padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;            OutlinedTextField(&#10;                value = query,&#10;                onValueChange = { query = it },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                label = { Text(&quot;Buscar&quot;) },&#10;                singleLine = true&#10;            )&#10;&#10;            val productById = remember(products) { products.associateBy { it.id } }&#10;&#10;            LazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {&#10;                item {&#10;                    FilterChip(selected = selectedCategoryId == null, onClick = { selectedCategoryId = null }, label = { Text(&quot;Todas&quot;) })&#10;                }&#10;                items(chipCategories.size) { i -&gt;&#10;                    val (id, name) = chipCategories[i]&#10;                    FilterChip(selected = selectedCategoryId == id, onClick = { selectedCategoryId = id }, label = { Text(name) })&#10;                }&#10;            }&#10;&#10;            HorizontalDivider()&#10;&#10;            LazyColumn(Modifier.fillMaxWidth().weight(1f), contentPadding = PaddingValues(bottom = 88.dp)) {&#10;                if (pantryItems.isEmpty()) {&#10;                    item { Text(&quot;Sin productos en la alacena&quot;, style = MaterialTheme.typography.bodyMedium) }&#10;                } else {&#10;                    items(pantryItems.size) { idx -&gt;&#10;                        val pi = pantryItems[idx]&#10;                        val p = productById[pi.productId]&#10;                        PantryRow(&#10;                            name = p?.name ?: &quot;Producto&quot;,&#10;                            unit = p?.unit?.ifBlank { &quot;u&quot; } ?: &quot;u&quot;,&#10;                            quantity = pi.quantity,&#10;                            onInc = { scope.launch { repo.updatePantryItem(pi.id, pi.quantity + 1) } },&#10;                            onDec = { if (pi.quantity &gt; 1) scope.launch { repo.updatePantryItem(pi.id, pi.quantity - 1) } },&#10;                            onDelete = { scope.launch { repo.deletePantryItem(pi.id) } }&#10;                        )&#10;                        HorizontalDivider()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAdd) {&#10;        val categoryById: Map&lt;Long, Category&gt; = remember(categories) { categories.associateBy { it.id } }&#10;        AddPantryItemDialog(&#10;            products = products,&#10;            categories = categories.map { it.name },&#10;            categoryNameFor = { pid -&gt;&#10;                val prod = products.firstOrNull { it.id == pid }&#10;                prod?.categoryId?.let { cid -&gt; categoryById[cid]?.name }&#10;            },&#10;            onDismiss = { showAdd = false },&#10;            onAdd = { productId, name, price, unit, categoryName -&gt;&#10;                scope.launch {&#10;                    try {&#10;                        val finalProductId = if (productId != null) {&#10;                            val existing = products.firstOrNull { it.id == productId }&#10;                            if (!name.isNullOrBlank() || price != null || !unit.isNullOrBlank() || !categoryName.isNullOrBlank()) {&#10;                                val catId = categoryName?.takeIf { it.isNotBlank() }?.let { repo.createOrFindCategoryByName(it) } ?: existing?.categoryId&#10;                                repo.updateProductRemote(productId, name ?: existing?.name ?: &quot;&quot;, price ?: existing?.price ?: 0.0, unit ?: existing?.unit ?: &quot;u&quot;, catId)&#10;                            }&#10;                            productId&#10;                        } else {&#10;                            val catId = categoryName?.takeIf { it.isNotBlank() }?.let { repo.createOrFindCategoryByName(it) }&#10;                            repo.createProductRemote(name!!.trim(), price ?: 0.0, unit ?: &quot;u&quot;, catId)&#10;                        }&#10;                        repo.addOrIncrementPantryItem(finalProductId, addQuantity = 1, unit = unit ?: &quot;u&quot;)&#10;                        runCatching { repo.syncPantry() }&#10;                        showAdd = false&#10;                    } catch (t: Throwable) {&#10;                        snack.showSnackbar(t.message ?: &quot;No se pudo agregar el producto a la alacena&quot;)&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun AddPantryItemDialog(&#10;    products: List&lt;Product&gt;,&#10;    categories: List&lt;String&gt;,&#10;    categoryNameFor: (Long) -&gt; String?,&#10;    onDismiss: () -&gt; Unit,&#10;    onAdd: (productId: Long?, name: String?, price: Double?, unit: String?, categoryName: String?) -&gt; Unit&#10;) {&#10;    var name by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var selectedId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var priceText by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var unit by rememberSaveable { mutableStateOf(&quot;u&quot;) }&#10;    var category by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var busy by remember { mutableStateOf(false) }&#10;&#10;    fun prefill(product: Product) {&#10;        name = product.name&#10;        priceText = if (product.price != 0.0) product.price.toString() else &quot;&quot;&#10;        unit = product.unit.ifBlank { &quot;u&quot; }&#10;        category = categoryNameFor(product.id) ?: &quot;&quot;&#10;    }&#10;&#10;    val suggestions = remember(name, products) {&#10;        val q = name.trim()&#10;        if (q.isBlank()) emptyList() else products.filter { it.name.contains(q, ignoreCase = true) }.take(8)&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                busy = true&#10;                val price = priceText.toDoubleOrNull()&#10;                onAdd(selectedId, if (selectedId == null) name else name.takeIf { it.isNotBlank() }, price, unit, category.ifBlank { null })&#10;                busy = false&#10;            }, enabled = !busy &amp;&amp; (selectedId != null || name.isNotBlank())) { Text(&quot;Agregar&quot;) }&#10;        },&#10;        dismissButton = { TextButton(onClick = { if (!busy) onDismiss() }) { Text(&quot;Cancelar&quot;) } },&#10;        title = { Text(&quot;Agregar a la alacena&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(&#10;                    value = name,&#10;                    onValueChange = { v -&gt;&#10;                        name = v&#10;                        val match = products.firstOrNull { it.name.equals(v, ignoreCase = true) }&#10;                        selectedId = match?.id&#10;                        if (match != null) prefill(match)&#10;                    },&#10;                    label = { Text(&quot;Producto&quot;) },&#10;                    singleLine = true&#10;                )&#10;                if (suggestions.isNotEmpty()) {&#10;                    suggestions.forEach { s -&gt;&#10;                        TextButton(onClick = { selectedId = s.id; prefill(s); name = s.name }) { Text(s.name) }&#10;                    }&#10;                }&#10;                OutlinedTextField(value = priceText, onValueChange = { priceText = it.filter { ch -&gt; ch.isDigit() || ch == '.' } }, label = { Text(&quot;Precio (opcional)&quot;) }, singleLine = true)&#10;                OutlinedTextField(value = unit, onValueChange = { unit = it }, label = { Text(&quot;Unidad&quot;) }, singleLine = true)&#10;                OutlinedTextField(value = category, onValueChange = { category = it }, label = { Text(&quot;Categoría (opcional)&quot;) }, singleLine = true)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun PantryRow(&#10;    name: String,&#10;    unit: String,&#10;    quantity: Int,&#10;    onInc: () -&gt; Unit,&#10;    onDec: () -&gt; Unit,&#10;    onDelete: () -&gt; Unit&#10;) {&#10;    ListItem(&#10;        headlineContent = { Text(name) },&#10;        supportingContent = { Text(&quot;$unit x $quantity&quot;) },&#10;        trailingContent = {&#10;            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                TextButton(onClick = onDec) { Text(&quot;-&quot;) }&#10;                Text(quantity.toString())&#10;                TextButton(onClick = onInc) { Text(&quot;+&quot;) }&#10;                IconButton(onClick = onDelete) { Icon(Icons.Default.Delete, contentDescription = null) }&#10;            }&#10;        }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.tuchanguito.ui.screens.pantry&#10;&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.dp&#10;import com.example.tuchanguito.data.AppRepository&#10;import com.example.tuchanguito.data.model.Category&#10;import com.example.tuchanguito.data.model.Product&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PantryScreen() {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val repo = remember { AppRepository.get(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val pantryItems by repo.pantry().collectAsState(initial = emptyList())&#10;    val products by repo.products().collectAsState(initial = emptyList())&#10;    val categories by repo.categories().collectAsState(initial = emptyList())&#10;&#10;    val snack = remember { SnackbarHostState() }&#10;&#10;    var query by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var selectedCategoryId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var showAdd by rememberSaveable { mutableStateOf(false) }&#10;&#10;    // Backend-driven categories for chips (stable for current search)&#10;    var chipCategories by remember { mutableStateOf&lt;List&lt;Pair&lt;Long, String&gt;&gt;&gt;(emptyList()) }&#10;&#10;    // Load categories for current search text&#10;    LaunchedEffect(query) {&#10;        val list = runCatching { repo.pantryCategoriesForQuery(query.ifBlank { null }) }.getOrDefault(emptyList())&#10;        chipCategories = list.mapNotNull { it.id?.let { id -&gt; id to it.name } }&#10;        if (selectedCategoryId != null &amp;&amp; chipCategories.none { it.first == selectedCategoryId }) {&#10;            selectedCategoryId = null&#10;        }&#10;    }&#10;&#10;    // Sync pantry items when search or selected category changes&#10;    LaunchedEffect(query, selectedCategoryId) {&#10;        runCatching { repo.syncPantry(search = query.ifBlank { null }, categoryId = selectedCategoryId) }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = { TopAppBar(title = { Text(&quot;Alacena&quot;) }) },&#10;        snackbarHost = { SnackbarHost(snack) },&#10;        floatingActionButton = { FloatingActionButton(onClick = { showAdd = true }) { Icon(Icons.Default.Add, contentDescription = null) } },&#10;        contentWindowInsets = WindowInsets.systemBars&#10;    ) { padding -&gt;&#10;        Column(Modifier.fillMaxSize().padding(padding).padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;            OutlinedTextField(&#10;                value = query,&#10;                onValueChange = { query = it },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                label = { Text(&quot;Buscar&quot;) },&#10;                singleLine = true&#10;            )&#10;&#10;            val productById = remember(products) { products.associateBy { it.id } }&#10;&#10;            LazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {&#10;                item {&#10;                    FilterChip(selected = selectedCategoryId == null, onClick = { selectedCategoryId = null }, label = { Text(&quot;Todas&quot;) })&#10;                }&#10;                items(chipCategories.size) { i -&gt;&#10;                    val (id, name) = chipCategories[i]&#10;                    FilterChip(selected = selectedCategoryId == id, onClick = { selectedCategoryId = id }, label = { Text(name) })&#10;                }&#10;            }&#10;&#10;            HorizontalDivider()&#10;&#10;            LazyColumn(Modifier.fillMaxWidth().weight(1f), contentPadding = PaddingValues(bottom = 88.dp)) {&#10;                if (pantryItems.isEmpty()) {&#10;                    item { Text(&quot;Sin productos en la alacena&quot;, style = MaterialTheme.typography.bodyMedium) }&#10;                } else {&#10;                    items(pantryItems.size) { idx -&gt;&#10;                        val pi = pantryItems[idx]&#10;                        val p = productById[pi.productId]&#10;                        PantryRow(&#10;                            name = p?.name ?: &quot;Producto&quot;,&#10;                            unit = p?.unit?.ifBlank { &quot;u&quot; } ?: &quot;u&quot;,&#10;                            quantity = pi.quantity,&#10;                            onInc = { scope.launch { repo.updatePantryItem(pi.id, pi.quantity + 1) } },&#10;                            onDec = { if (pi.quantity &gt; 1) scope.launch { repo.updatePantryItem(pi.id, pi.quantity - 1) } },&#10;                            onDelete = { scope.launch { repo.deletePantryItem(pi.id) } }&#10;                        )&#10;                        HorizontalDivider()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAdd) {&#10;        val categoryById: Map&lt;Long, Category&gt; = remember(categories) { categories.associateBy { it.id } }&#10;        AddPantryItemDialog(&#10;            products = products,&#10;            categories = categories.map { it.name },&#10;            categoryNameFor = { pid -&gt;&#10;                val prod = products.firstOrNull { it.id == pid }&#10;                prod?.categoryId?.let { cid -&gt; categoryById[cid]?.name }&#10;            },&#10;            onDismiss = { showAdd = false },&#10;            onAdd = { productId, name, price, unit, categoryName -&gt;&#10;                scope.launch {&#10;                    try {&#10;                        val finalProductId = if (productId != null) {&#10;                            val existing = products.firstOrNull { it.id == productId }&#10;                            if (!name.isNullOrBlank() || price != null || !unit.isNullOrBlank() || !categoryName.isNullOrBlank()) {&#10;                                val catId = categoryName?.takeIf { it.isNotBlank() }?.let { repo.createOrFindCategoryByName(it) } ?: existing?.categoryId&#10;                                repo.updateProductRemote(productId, name ?: existing?.name ?: &quot;&quot;, price ?: existing?.price ?: 0.0, unit ?: existing?.unit ?: &quot;u&quot;, catId)&#10;                            }&#10;                            productId&#10;                        } else {&#10;                            val catId = categoryName?.takeIf { it.isNotBlank() }?.let { repo.createOrFindCategoryByName(it) }&#10;                            repo.createProductRemote(name!!.trim(), price ?: 0.0, unit ?: &quot;u&quot;, catId)&#10;                        }&#10;                        repo.addOrIncrementPantryItem(finalProductId, addQuantity = 1, unit = unit ?: &quot;u&quot;)&#10;                        runCatching { repo.syncPantry() }&#10;                        showAdd = false&#10;                    } catch (t: Throwable) {&#10;                        snack.showSnackbar(t.message ?: &quot;No se pudo agregar el producto a la alacena&quot;)&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun AddPantryItemDialog(&#10;    products: List&lt;Product&gt;,&#10;    categories: List&lt;String&gt;,&#10;    categoryNameFor: (Long) -&gt; String?,&#10;    onDismiss: () -&gt; Unit,&#10;    onAdd: (productId: Long?, name: String?, price: Double?, unit: String?, categoryName: String?) -&gt; Unit&#10;) {&#10;    var name by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var selectedId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var priceText by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var unit by rememberSaveable { mutableStateOf(&quot;u&quot;) }&#10;    var category by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var busy by remember { mutableStateOf(false) }&#10;&#10;    fun prefill(product: Product) {&#10;        name = product.name&#10;        priceText = if (product.price != 0.0) product.price.toString() else &quot;&quot;&#10;        unit = product.unit.ifBlank { &quot;u&quot; }&#10;        category = categoryNameFor(product.id) ?: &quot;&quot;&#10;    }&#10;&#10;    val suggestions = remember(name, products) {&#10;        val q = name.trim()&#10;        if (q.isBlank()) emptyList() else products.filter { it.name.contains(q, ignoreCase = true) }.take(8)&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                busy = true&#10;                val price = priceText.toDoubleOrNull()&#10;                onAdd(selectedId, if (selectedId == null) name else name.takeIf { it.isNotBlank() }, price, unit, category.ifBlank { null })&#10;                busy = false&#10;            }, enabled = !busy &amp;&amp; (selectedId != null || name.isNotBlank())) { Text(&quot;Agregar&quot;) }&#10;        },&#10;        dismissButton = { TextButton(onClick = { if (!busy) onDismiss() }) { Text(&quot;Cancelar&quot;) } },&#10;        title = { Text(&quot;Agregar a la alacena&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(&#10;                    value = name,&#10;                    onValueChange = { v -&gt;&#10;                        name = v&#10;                        val match = products.firstOrNull { it.name.equals(v, ignoreCase = true) }&#10;                        selectedId = match?.id&#10;                        if (match != null) prefill(match)&#10;                    },&#10;                    label = { Text(&quot;Producto&quot;) },&#10;                    singleLine = true&#10;                )&#10;                if (suggestions.isNotEmpty()) {&#10;                    suggestions.forEach { s -&gt;&#10;                        TextButton(onClick = { selectedId = s.id; prefill(s); name = s.name }) { Text(s.name) }&#10;                    }&#10;                }&#10;                OutlinedTextField(value = priceText, onValueChange = { priceText = it.filter { ch -&gt; ch.isDigit() || ch == '.' } }, label = { Text(&quot;Precio (opcional)&quot;) }, singleLine = true)&#10;                OutlinedTextField(value = unit, onValueChange = { unit = it }, label = { Text(&quot;Unidad&quot;) }, singleLine = true)&#10;                OutlinedTextField(value = category, onValueChange = { category = it }, label = { Text(&quot;Categoría (opcional)&quot;) }, singleLine = true)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun PantryRow(&#10;    name: String,&#10;    unit: String,&#10;    quantity: Int,&#10;    onInc: () -&gt; Unit,&#10;    onDec: () -&gt; Unit,&#10;    onDelete: () -&gt; Unit&#10;) {&#10;    ListItem(&#10;        headlineContent = { Text(name) },&#10;        trailingContent = {&#10;            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                TextButton(onClick = onDec) { Text(&quot;-&quot;) }&#10;                Text(quantity.toString())&#10;                TextButton(onClick = onInc) { Text(&quot;+&quot;) }&#10;                IconButton(onClick = onDelete) { Icon(Icons.Default.Delete, contentDescription = null) }&#10;            }&#10;        }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>