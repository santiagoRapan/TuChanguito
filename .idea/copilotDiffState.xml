<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/data/AppRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/data/AppRepository.kt" />
              <option name="originalContent" value="package com.example.tuchanguito.data&#10;&#10;import android.content.Context&#10;import com.example.tuchanguito.data.db.AppDatabase&#10;import com.example.tuchanguito.data.model.*&#10;import com.example.tuchanguito.network.ApiModule&#10;import com.example.tuchanguito.network.dto.CredentialsDTO&#10;import com.example.tuchanguito.network.dto.RegistrationDataDTO&#10;import com.example.tuchanguito.network.dto.CategoryDTO&#10;import com.example.tuchanguito.network.dto.ProductDTO&#10;import com.example.tuchanguito.network.dto.ProductRegistrationDTO&#10;import com.example.tuchanguito.network.dto.IdRef&#10;import com.example.tuchanguito.network.dto.ListItemDTO&#10;import com.example.tuchanguito.network.dto.PantryItemDTO&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;&#10;/**&#10; * Simple repository coordinating Room DAOs for the app features.&#10; */&#10;class AppRepository private constructor(context: Context){&#10;    private val db = AppDatabase.get(context)&#10;    private val userDao = db.userDao()&#10;    private val productDao = db.productDao()&#10;    private val categoryDao = db.categoryDao()&#10;    private val listDao = db.shoppingListDao()&#10;    private val itemDao = db.listItemDao()&#10;    private val pantryDao = db.pantryDao()&#10;    private val api = ApiModule(context)&#10;    private val prefs = PreferencesManager(context)&#10;&#10;    // In-memory source of truth for lists fetched from API&#10;    private val _remoteLists = MutableStateFlow&lt;List&lt;ShoppingList&gt;&gt;(emptyList())&#10;    val remoteLists = _remoteLists.asStateFlow()&#10;&#10;    // Auth (local)&#10;    suspend fun register(email: String, password: String, displayName: String): Result&lt;Unit&gt; = try {&#10;        // Remote first (adjust names/surnames as needed)&#10;        val names = displayName.split(&quot; &quot;)&#10;        val name = names.firstOrNull() ?: displayName&#10;        val surname = names.drop(1).joinToString(&quot; &quot;)&#10;        api.auth.register(RegistrationDataDTO(email = email, name = name, surname = surname, password = password))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun verifyAccount(email: String, code: String): Result&lt;Unit&gt; = try {&#10;        api.auth.verify(com.example.tuchanguito.network.dto.VerificationCodeDTO(code))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;Unit&gt; = try {&#10;        val token = api.auth.login(CredentialsDTO(email, password)).token&#10;        prefs.setAuthToken(token)&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun changePassword(old: String, new: String): Result&lt;Unit&gt; = try {&#10;        api.auth.changePassword(com.example.tuchanguito.network.dto.PasswordChangeDTO(currentPassword = old, newPassword = new))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Profile&#10;    suspend fun getProfile(): Result&lt;com.example.tuchanguito.network.dto.UserDTO&gt; = try {&#10;        val user = api.auth.getProfile()&#10;        // store current user id&#10;        prefs.setCurrentUserId(user.id)&#10;        Result.success(user)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun updateProfile(name: String?, surname: String?): Result&lt;com.example.tuchanguito.network.dto.UserDTO&gt; = try {&#10;        val updated = api.auth.updateProfile(com.example.tuchanguito.network.dto.UserUpdateDTO(name = name, surname = surname))&#10;        prefs.setCurrentUserId(updated.id)&#10;        Result.success(updated)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Products&#10;    fun categories(): Flow&lt;List&lt;Category&gt;&gt; = categoryDao.observeAll()&#10;    fun products(): Flow&lt;List&lt;Product&gt;&gt; = productDao.observeAll()&#10;    suspend fun upsertCategory(name: String) = categoryDao.upsert(Category(name = name))&#10;    suspend fun upsertProduct(product: Product) = productDao.upsert(product)&#10;    suspend fun deleteProduct(product: Product) = productDao.delete(product)&#10;&#10;    // Catalog sync with API&#10;    suspend fun syncCatalog(): Result&lt;Unit&gt; = try {&#10;        // Clear local snapshot before re-hydrating to avoid ghost data after API switch&#10;        categoryDao.clearAll()&#10;        productDao.clearAll()&#10;        // Categories&#10;        val catPage = api.catalog.getCategories(page = 1, perPage = 1000)&#10;        catPage.data.forEach { c -&gt;&#10;            categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name))&#10;        }&#10;        // Products&#10;        val prodPage = api.catalog.getProducts(page = 1, perPage = 1000)&#10;        prodPage.data.forEach { p -&gt;&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unit = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val catId = p.category?.id&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unit))&#10;        }&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun createOrFindCategoryByName(name: String): Long {&#10;        val trimmed = name.trim()&#10;        // Try remote search&#10;        val found = runCatching { api.catalog.getCategories(name = trimmed, page = 1, perPage = 1) }.getOrNull()&#10;        val existing = found?.data?.firstOrNull { it.name.equals(trimmed, ignoreCase = true) }&#10;        if (existing != null) {&#10;            categoryDao.upsert(Category(id = existing.id ?: 0L, name = existing.name))&#10;            return existing.id ?: 0L&#10;        }&#10;        // Create&#10;        val created = api.catalog.createCategory(CategoryDTO(name = trimmed))&#10;        categoryDao.upsert(Category(id = created.id ?: 0L, name = created.name))&#10;        return created.id ?: 0L&#10;    }&#10;&#10;    suspend fun createProductRemote(name: String, price: Double, unit: String, categoryId: Long?): Long {&#10;        // Resolve category: if id came from local DB but doesn’t exist remotely, create it first&#10;        val finalCatId = if (categoryId != null) {&#10;            // Try to fetch remote category; if missing, create by local name fallback&#10;            val remoteOk = runCatching { api.catalog.getCategories(page = 1, perPage = 1000) }.getOrNull()?.data?.any { it.id == categoryId } == true&#10;            if (remoteOk) categoryId else {&#10;                // Try to read local name and recreate remotely&#10;                val localName = runCatching { categoryDao.getById(categoryId)?.name }.getOrNull()&#10;                if (!localName.isNullOrBlank()) createOrFindCategoryByName(localName) else categoryId&#10;            }&#10;        } else null&#10;&#10;        val resp = api.catalog.createProduct(&#10;            ProductRegistrationDTO(&#10;                name = name,&#10;                category = finalCatId?.let { IdRef(it) },&#10;                metadata = mapOf(&quot;price&quot; to price, &quot;unit&quot; to unit)&#10;            )&#10;        )&#10;        if (!resp.isSuccessful) {&#10;            // Attempt to find existing product with same name (409 Conflict case)&#10;            val page = runCatching { api.catalog.getProducts(name = name, page = 1, perPage = 1) }.getOrNull()&#10;            val existing = page?.data?.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;            if (existing != null) {&#10;                val exId = existing.id ?: 0L&#10;                val pPrice = (existing.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;                val pUnit = (existing.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;                productDao.upsert(Product(id = exId, name = existing.name, price = pPrice, categoryId = existing.category?.id, unit = pUnit))&#10;                return exId&#10;            }&#10;            throw IllegalStateException(&quot;Error creando producto: HTTP ${'$'}{resp.code()}&quot;)&#10;        }&#10;        // Some servers return minimal/empty body on create; fetch by name to locate the created product&#10;        val page = runCatching { api.catalog.getProducts(name = name, page = 1, perPage = 1) }.getOrNull()&#10;        val dto = page?.data?.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;            ?: throw IllegalStateException(&quot;Producto creado pero no encontrado por nombre&quot;)&#10;        val pId = dto.id ?: 0L&#10;        val pCatId = dto.category?.id&#10;        val pPrice = (dto.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;        val pUnit = (dto.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;        productDao.upsert(Product(id = pId, name = dto.name, price = pPrice, categoryId = pCatId, unit = pUnit))&#10;        // Ensure list shows all current remote products&#10;        syncProducts()&#10;        return pId&#10;    }&#10;&#10;    suspend fun updateProductRemote(id: Long, name: String, price: Double, unit: String, categoryId: Long?) {&#10;        val resp = api.catalog.updateProduct(&#10;            id,&#10;            ProductRegistrationDTO(&#10;                name = name,&#10;                category = categoryId?.let { IdRef(it) },&#10;                metadata = mapOf(&quot;price&quot; to price, &quot;unit&quot; to unit)&#10;            )&#10;        )&#10;        if (!resp.isSuccessful) {&#10;            throw IllegalStateException(&quot;Error actualizando producto: HTTP ${'$'}{resp.code()}&quot;)&#10;        }&#10;        // Regardless of body, fetch latest from server to ensure final state matches backend rules&#10;        val server = runCatching { api.catalog.getProduct(id) }.getOrNull()&#10;        val pCatId = server?.category?.id ?: categoryId&#10;        val pPrice = (server?.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;        val pUnit = (server?.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;        val pName = server?.name ?: name&#10;        productDao.upsert(Product(id = id, name = pName, price = pPrice, categoryId = pCatId, unit = pUnit))&#10;        // Refresh full list to avoid partial state&#10;        syncProducts()&#10;    }&#10;&#10;    suspend fun deleteProductRemote(id: Long) {&#10;        api.catalog.deleteProduct(id)&#10;        productDao.getById(id)?.let { productDao.delete(it) }&#10;        // Refresh remote to ensure local matches server after deletion&#10;        syncProducts()&#10;    }&#10;&#10;    private suspend fun syncProducts() {&#10;        runCatching { api.catalog.getProducts(page = 1, perPage = 1000) }&#10;            .onSuccess { page -&gt;&#10;                page.data.forEach { p -&gt;&#10;                    val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;                    val unit = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                    val catId = p.category?.id&#10;                    productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unit))&#10;                }&#10;            }&#10;    }&#10;&#10;    // Lists (API-backed)&#10;    fun activeLists(): Flow&lt;List&lt;ShoppingList&gt;&gt; = remoteLists&#10;    fun listById(id: Long): Flow&lt;ShoppingList?&gt; = listDao.observeById(id)&#10;    suspend fun loadListIntoLocal(id: Long) {&#10;        // Fetch remote list and persist into Room so UI detail observes correct title&#10;        runCatching { api.shopping.getList(id) }&#10;            .onSuccess { dto -&gt; listDao.upsert(ShoppingList(id = dto.id, title = dto.name)) }&#10;    }&#10;&#10;    suspend fun refreshLists(): Result&lt;Unit&gt; = try {&#10;        val page = api.shopping.getLists()&#10;        val lists = page.data.map { ShoppingList(id = it.id, title = it.name) }&#10;        _remoteLists.value = lists&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        // Keep previous cache and report failure without throwing&#10;        Result.failure(t)&#10;    }&#10;&#10;    private suspend fun existsListWithName(name: String): Boolean {&#10;        return try {&#10;            // Ask API filtering by name and owner=true to check uniqueness on server&#10;            val page = api.shopping.getLists(name = name, owner = true, page = 1, perPage = 1)&#10;            page.data.any { it.name.equals(name, ignoreCase = true) }&#10;        } catch (_: Throwable) { false }&#10;    }&#10;&#10;    suspend fun createList(title: String): Long {&#10;        // API requires name, description (string) and recurring (boolean)&#10;        // Prevent 409 UNIQUE constraint by checking server-side duplicates first&#10;        if (existsListWithName(title)) throw IllegalStateException(&quot;Ya existe una lista con ese nombre&quot;)&#10;        val dto = api.shopping.createList(&#10;            com.example.tuchanguito.network.dto.ShoppingListCreateDTO(&#10;                name = title,&#10;                description = &quot;&quot;,&#10;                recurring = false,&#10;                metadata = emptyMap()&#10;            )&#10;        )&#10;        // Fetch server version to ensure fields are in sync, then update cache&#10;        val created = runCatching { api.shopping.getList(dto.id) }.getOrNull()&#10;        val model = if (created != null) ShoppingList(id = created.id, title = created.name) else ShoppingList(id = dto.id, title = dto.name)&#10;        _remoteLists.update { it + model }&#10;        // Also persist in Room so ListDetail observes the correct title immediately&#10;        listDao.upsert(model)&#10;        return dto.id&#10;    }&#10;&#10;    suspend fun renameList(id: Long, newTitle: String) {&#10;        if (existsListWithName(newTitle)) throw IllegalStateException(&quot;Ya existe una lista con ese nombre&quot;)&#10;        api.shopping.updateList(id, com.example.tuchanguito.network.dto.ShoppingListCreateDTO(name = newTitle))&#10;        _remoteLists.update { cur -&gt; cur.map { if (it.id == id) it.copy(title = newTitle) else it } }&#10;        // Keep Room in sync so ListDetail shows the updated title&#10;        listDao.upsert(ShoppingList(id = id, title = newTitle))&#10;    }&#10;&#10;    suspend fun deleteListRemote(id: Long) {&#10;        api.shopping.deleteList(id)&#10;        _remoteLists.update { cur -&gt; cur.filterNot { it.id == id } }&#10;    }&#10;&#10;    fun itemsForList(listId: Long): Flow&lt;List&lt;ListItem&gt;&gt; = itemDao.observeForList(listId)&#10;&#10;    private suspend fun fetchListItemsEither(listId: Long): List&lt;ListItemDTO&gt; {&#10;        // Try plain array first&#10;        return runCatching { api.shopping.getItems(listId) }.getOrElse {&#10;            // Fallback to page-wrapped structure&#10;            runCatching { api.shopping.getItemsPage(listId).data }.getOrElse { emptyList() }&#10;        }&#10;    }&#10;&#10;    suspend fun fetchListItemsRemote(listId: Long): List&lt;ListItemDTO&gt; = fetchListItemsEither(listId)&#10;&#10;    // --- New: API-backed list item operations ---&#10;    suspend fun syncListItems(listId: Long) {&#10;        // Ensure list exists locally (FK for list_items)&#10;        runCatching { api.shopping.getList(listId) }.onSuccess { dto -&gt;&#10;            listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;        }&#10;        val remoteItems = fetchListItemsEither(listId)&#10;        remoteItems.forEach { li -&gt;&#10;            val p = li.product&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val existing = runCatching { productDao.getById(p.id ?: 0L) }.getOrNull()&#10;            var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;            var finalCatId = p.category?.id ?: existing?.categoryId&#10;            // Hydrate missing category/unit from product endpoint when needed&#10;            if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;                runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                    finalCatId = full.category?.id ?: finalCatId&#10;                    val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                    if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                }&#10;            }&#10;            p.category?.let { categoryDto -&gt;&#10;                categoryDao.upsert(Category(id = categoryDto.id ?: 0L, name = categoryDto.name))&#10;            }&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;            itemDao.upsert(&#10;                ListItem(&#10;                    id = li.id,&#10;                    listId = listId,&#10;                    productId = p.id ?: 0L,&#10;                    quantity = li.quantity.toInt(),&#10;                    acquired = li.purchased&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    suspend fun addItemRemote(listId: Long, productId: Long, quantity: Int = 1, unit: String = &quot;u&quot;): Long {&#10;        return try {&#10;            val resp = api.shopping.addItem(listId, com.example.tuchanguito.network.dto.ListItemCreateDTO(product = IdRef(productId), quantity = quantity.toDouble(), unit = unit))&#10;            if (!resp.isSuccessful) throw retrofit2.HttpException(resp)&#10;            runCatching { api.shopping.getList(listId) }.onSuccess { dto -&gt;&#10;                listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;            }&#10;            val remoteItems = fetchListItemsEither(listId)&#10;            remoteItems.forEach { li -&gt;&#10;                val p = li.product&#10;                val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;                val unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                val existing = runCatching { productDao.getById(p.id ?: 0L) }.getOrNull()&#10;                var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;                var finalCatId = p.category?.id ?: existing?.categoryId&#10;                if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;                    runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                        finalCatId = full.category?.id ?: finalCatId&#10;                        val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                        if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                    }&#10;                }&#10;                p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;                productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;                itemDao.upsert(ListItem(id = li.id, listId = listId, productId = p.id ?: 0L, quantity = li.quantity.toInt(), acquired = li.purchased))&#10;            }&#10;            remoteItems.firstOrNull { it.product.id == productId }?.id&#10;                ?: remoteItems.maxByOrNull { it.id }?.id&#10;                ?: 0L&#10;        } catch (t: Throwable) {&#10;            val code = (t as? retrofit2.HttpException)?.code()&#10;            if (code == 409) {&#10;                val remoteItems = runCatching { fetchListItemsEither(listId) }.getOrDefault(emptyList())&#10;                val existing = remoteItems.firstOrNull { it.product.id == productId }&#10;                if (existing != null) {&#10;                    val newQty = existing.quantity.toInt() + quantity&#10;                    val chosenUnit = existing.unit.ifBlank { unit }&#10;                    updateItemQuantityRemote(listId, existing.id, productId, newQty, chosenUnit)&#10;                    existing.id&#10;                } else {&#10;                    throw t&#10;                }&#10;            } else {&#10;                throw t&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun updateItemQuantityRemote(listId: Long, itemId: Long, productId: Long, newQuantity: Int, unit: String = &quot;u&quot;) {&#10;        val updated = api.shopping.updateItem(listId, itemId, com.example.tuchanguito.network.dto.ListItemCreateDTO(product = IdRef(productId), quantity = newQuantity.toDouble(), unit = unit))&#10;        val p = updated.product&#10;        val existing = runCatching { productDao.getById(p.id ?: productId) }.getOrNull()&#10;        var price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: (existing?.price ?: 0.0)&#10;        var unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        var finalUnit = unitFromServer.ifBlank { existing?.unit ?: unit }&#10;        var finalCatId = p.category?.id ?: existing?.categoryId&#10;        if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;            runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                finalCatId = full.category?.id ?: finalCatId&#10;                val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                val pr = (full.metadata?.get(&quot;price&quot;) as? Number)?.toDouble()&#10;                if (pr != null) price = pr&#10;            }&#10;        }&#10;        p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        productDao.upsert(Product(id = p.id ?: productId, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;        itemDao.upsert(&#10;            ListItem(&#10;                id = updated.id,&#10;                listId = listId,&#10;                productId = updated.product.id ?: productId,&#10;                quantity = updated.quantity.toInt(),&#10;                acquired = updated.purchased&#10;            )&#10;        )&#10;    }&#10;&#10;    suspend fun toggleItemPurchasedRemote(listId: Long, itemId: Long, purchased: Boolean) {&#10;        val updated = api.shoppingPatch.togglePurchased(listId, itemId, mapOf(&quot;purchased&quot; to purchased))&#10;        val p = updated.product&#10;        val pId = p.id ?: 0L&#10;        val existing = runCatching { productDao.getById(pId) }.getOrNull()&#10;        var price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: (existing?.price ?: 0.0)&#10;        var unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;        var finalCatId = p.category?.id ?: existing?.categoryId&#10;        if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;            runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                finalCatId = full.category?.id ?: finalCatId&#10;                val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                val pr = (full.metadata?.get(&quot;price&quot;) as? Number)?.toDouble()&#10;                if (pr != null) price = pr&#10;            }&#10;        }&#10;        p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        productDao.upsert(Product(id = pId, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;        itemDao.upsert(ListItem(id = updated.id, listId = listId, productId = pId, quantity = updated.quantity.toInt(), acquired = updated.purchased))&#10;    }&#10;&#10;    suspend fun deleteItemRemote(listId: Long, itemId: Long, local: ListItem? = null) {&#10;        // Delete from server; ignore body&#10;        runCatching { api.shopping.deleteItem(listId, itemId) }&#10;            .onFailure { throw it }&#10;        // Remove local row by id (or provided entity) to keep Room in sync immediately&#10;        if (local != null) {&#10;            runCatching { itemDao.delete(local) }&#10;        }&#10;        runCatching { itemDao.deleteById(itemId) }&#10;        // Optionally refresh items from server to ensure correct state (quantities of other items may change)&#10;        runCatching { syncListItems(listId) }&#10;    }&#10;&#10;    suspend fun deleteItemByIdLocal(id: Long) = itemDao.deleteById(id)&#10;&#10;    // Local-only fallbacks preserved&#10;    suspend fun addItem(listId: Long, productId: Long, quantity: Int = 1) = itemDao.upsert(ListItem(listId = listId, productId = productId, quantity = quantity))&#10;    suspend fun updateItem(item: ListItem) = itemDao.update(item)&#10;    suspend fun removeItem(item: ListItem) = itemDao.delete(item)&#10;&#10;    // Pantry&#10;    fun pantry(): Flow&lt;List&lt;PantryItem&gt;&gt; = pantryDao.observeAll()&#10;&#10;    private suspend fun isPantryUsable(id: Long): Boolean {&#10;        return runCatching {&#10;            api.pantry.getItems(id, page = 1, perPage = 1)&#10;            true&#10;        }.getOrDefault(false)&#10;    }&#10;&#10;    suspend fun ensureDefaultPantryId(): Long {&#10;        // If we previously selected a pantry id and it remains usable, reuse it.&#10;        val saved = runCatching { prefs.currentPantryId.first() }.getOrNull()&#10;        if (saved != null &amp;&amp; isPantryUsable(saved)) return saved&#10;&#10;        val page = runCatching { api.pantry.getPantries(owner = true, page = 1, perPage = 100, sortBy = &quot;createdAt&quot;, order = &quot;DESC&quot;) }.getOrNull()&#10;        val candidates = page?.data.orEmpty()&#10;        val named = candidates.firstOrNull { it.name.equals(&quot;Alacena&quot;, ignoreCase = true) &amp;&amp; runCatching { isPantryUsable(it.id) }.getOrDefault(false) }&#10;        val chosen = named ?: candidates.firstOrNull { runCatching { isPantryUsable(it.id) }.getOrDefault(false) }&#10;        if (chosen != null) {&#10;            runCatching { prefs.setCurrentPantryId(chosen.id) }&#10;            return chosen.id&#10;        }&#10;        val created = api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena&quot;))&#10;        runCatching { prefs.setCurrentPantryId(created.id) }&#10;        return created.id&#10;    }&#10;&#10;    private suspend fun createFreshPantry(): Long {&#10;        // Try default name; if conflict, suffix with timestamp fragment&#10;        val tryNames = listOf(&quot;Alacena&quot;, &quot;Alacena ${System.currentTimeMillis() % 10000}&quot;)&#10;        for (n in tryNames) {&#10;            val created = runCatching { api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = n)) }.getOrNull()&#10;            if (created != null) return created.id&#10;        }&#10;        // Last resort&#10;        val fallback = api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena ${System.currentTimeMillis()}&quot;))&#10;        return fallback.id&#10;    }&#10;&#10;    suspend fun syncPantry(search: String? = null, categoryId: Long? = null) {&#10;        var pantryId = ensureDefaultPantryId()&#10;        // Reset local mirror before rehydrating from server to avoid stale/corrupt rows from a previous pantry&#10;        runCatching { pantryDao.clearAll() }&#10;        var page = runCatching { api.pantry.getItems(pantryId, search = search, categoryId = categoryId, page = 1, perPage = 1000, sortBy = &quot;productName&quot;, order = &quot;DESC&quot;) }.getOrNull()&#10;        if (page == null) {&#10;            // The selected pantry is not usable (backend 500). Create a fresh pantry and retry once.&#10;            pantryId = runCatching { createFreshPantry() }.getOrElse { pantryId }&#10;            runCatching { prefs.setCurrentPantryId(pantryId) }&#10;            page = runCatching { api.pantry.getItems(pantryId, search = search, categoryId = categoryId, page = 1, perPage = 1000, sortBy = &quot;productName&quot;, order = &quot;DESC&quot;) }.getOrNull()&#10;            if (page == null) return // fail silently to avoid crashing UI&#10;        }&#10;        val items = page.data&#10;        // Upsert products/categories and mirror pantry items&#10;        items.forEach { it -&gt;&#10;            val p = it.product&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unitMeta = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val catId = p.category?.id&#10;            p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unitMeta))&#10;            pantryDao.upsert(PantryItem(id = it.id, productId = p.id ?: 0L, quantity = it.quantity.toInt()))&#10;        }&#10;    }&#10;&#10;    suspend fun addPantryItem(productId: Long, quantity: Int, unit: String = &quot;u&quot;) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        val created = api.pantry.addItem(pantryId, com.example.tuchanguito.network.dto.PantryItemCreateDTO(product = com.example.tuchanguito.network.dto.IdRef(productId), quantity = quantity.toDouble(), unit = unit))&#10;        // Upsert related product/category then mirror item&#10;        created.product.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        val pPrice = (created.product.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;        val pUnit = (created.product.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        productDao.upsert(Product(id = created.product.id ?: productId, name = created.product.name, price = pPrice, categoryId = created.product.category?.id, unit = pUnit))&#10;        pantryDao.upsert(PantryItem(id = created.id, productId = created.product.id ?: productId, quantity = created.quantity.toInt()))&#10;    }&#10;&#10;    // Add-or-increment pantry item if a row for the same product already exists&#10;    suspend fun addOrIncrementPantryItem(productId: Long, addQuantity: Int, unit: String = &quot;u&quot;) {&#10;        // First ensure we have current pantry snapshot locally&#10;        runCatching { syncPantry() }&#10;        val existing = pantryDao.findByProduct(productId)&#10;        if (existing != null) {&#10;            // Update quantity via API using existing item id&#10;            updatePantryItem(existing.id, existing.quantity + addQuantity, unit)&#10;        } else {&#10;            addPantryItem(productId, addQuantity, unit)&#10;        }&#10;    }&#10;&#10;    suspend fun updatePantryItem(itemId: Long, quantity: Int, unit: String = &quot;u&quot;) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        val updated = api.pantry.updateItem(pantryId, itemId, com.example.tuchanguito.network.dto.PantryItemUpdateDTO(quantity = quantity.toDouble(), unit = unit))&#10;        pantryDao.upsert(PantryItem(id = updated.id, productId = updated.product.id ?: 0L, quantity = updated.quantity.toInt()))&#10;    }&#10;&#10;    suspend fun deletePantryItem(itemId: Long) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        runCatching { api.pantry.deleteItem(pantryId, itemId) }&#10;            .onFailure { throw it }&#10;        // Clean local row safely by id&#10;        runCatching { pantryDao.deleteById(itemId) }&#10;        // Refresh to ensure UI consistent&#10;        runCatching { syncPantry() }&#10;    }&#10;&#10;    // Validate Credentials&#10;    suspend fun validateCredentials(email: String, password: String): Result&lt;Unit&gt; = try {&#10;        api.auth.login(com.example.tuchanguito.network.dto.CredentialsDTO(email, password))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // --- Backend-driven product search helpers for ProductsScreen ---&#10;    suspend fun searchProductsDTO(name: String?, categoryId: Long?): List&lt;ProductDTO&gt; {&#10;        val page = api.catalog.getProducts(name = name?.takeIf { it.isNotBlank() }, categoryId = categoryId, page = 1, perPage = 1000)&#10;        return page.data&#10;    }&#10;&#10;    suspend fun categoriesForQuery(name: String?): List&lt;CategoryDTO&gt; {&#10;        val page = api.catalog.getProducts(name = name?.takeIf { it.isNotBlank() }, categoryId = null, page = 1, perPage = 1000)&#10;        val distinct = LinkedHashMap&lt;Long, CategoryDTO&gt;()&#10;        page.data.forEach { p -&gt;&#10;            val c = p.category&#10;            if (c?.id != null &amp;&amp; !distinct.containsKey(c.id!!)) distinct[c.id!!] = CategoryDTO(id = c.id, name = c.name, metadata = c.metadata)&#10;        }&#10;        return distinct.values.toList().sortedBy { it.name.lowercase() }&#10;    }&#10;&#10;    // --- New: share shopping list with user by email ---&#10;    suspend fun shareListRemote(listId: Long, email: String) {&#10;        val dto = api.shopping.shareList(listId, com.example.tuchanguito.network.dto.ShareRequestDTO(email))&#10;        // Update local Room title (still the same name) and refresh remote lists so the shared user view is consistent&#10;        listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;        runCatching { refreshLists() }&#10;    }&#10;&#10;    companion object {&#10;        @Volatile private var INSTANCE: AppRepository? = null&#10;        fun get(context: Context): AppRepository = INSTANCE ?: synchronized(this) {&#10;            INSTANCE ?: AppRepository(context.applicationContext).also { INSTANCE = it }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.tuchanguito.data&#10;&#10;import android.content.Context&#10;import com.example.tuchanguito.data.db.AppDatabase&#10;import com.example.tuchanguito.data.model.*&#10;import com.example.tuchanguito.network.ApiModule&#10;import com.example.tuchanguito.network.dto.CredentialsDTO&#10;import com.example.tuchanguito.network.dto.RegistrationDataDTO&#10;import com.example.tuchanguito.network.dto.CategoryDTO&#10;import com.example.tuchanguito.network.dto.ProductDTO&#10;import com.example.tuchanguito.network.dto.ProductRegistrationDTO&#10;import com.example.tuchanguito.network.dto.IdRef&#10;import com.example.tuchanguito.network.dto.ListItemDTO&#10;import com.example.tuchanguito.network.dto.PantryItemDTO&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;&#10;/**&#10; * Simple repository coordinating Room DAOs for the app features.&#10; */&#10;class AppRepository private constructor(context: Context){&#10;    private val db = AppDatabase.get(context)&#10;    private val userDao = db.userDao()&#10;    private val productDao = db.productDao()&#10;    private val categoryDao = db.categoryDao()&#10;    private val listDao = db.shoppingListDao()&#10;    private val itemDao = db.listItemDao()&#10;    private val pantryDao = db.pantryDao()&#10;    private val api = ApiModule(context)&#10;    private val prefs = PreferencesManager(context)&#10;&#10;    // Cache en memoria del pantry id activo para evitar sondas repetidas&#10;    private var cachedPantryId: Long? = null&#10;&#10;    // In-memory source of truth for lists fetched from API&#10;    private val _remoteLists = MutableStateFlow&lt;List&lt;ShoppingList&gt;&gt;(emptyList())&#10;    val remoteLists = _remoteLists.asStateFlow()&#10;&#10;    // Auth (local)&#10;    suspend fun register(email: String, password: String, displayName: String): Result&lt;Unit&gt; = try {&#10;        // Remote first (adjust names/surnames as needed)&#10;        val names = displayName.split(&quot; &quot;)&#10;        val name = names.firstOrNull() ?: displayName&#10;        val surname = names.drop(1).joinToString(&quot; &quot;)&#10;        api.auth.register(RegistrationDataDTO(email = email, name = name, surname = surname, password = password))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun verifyAccount(email: String, code: String): Result&lt;Unit&gt; = try {&#10;        api.auth.verify(com.example.tuchanguito.network.dto.VerificationCodeDTO(code))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;Unit&gt; = try {&#10;        val token = api.auth.login(CredentialsDTO(email, password)).token&#10;        prefs.setAuthToken(token)&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun changePassword(old: String, new: String): Result&lt;Unit&gt; = try {&#10;        api.auth.changePassword(com.example.tuchanguito.network.dto.PasswordChangeDTO(currentPassword = old, newPassword = new))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Profile&#10;    suspend fun getProfile(): Result&lt;com.example.tuchanguito.network.dto.UserDTO&gt; = try {&#10;        val user = api.auth.getProfile()&#10;        // store current user id&#10;        prefs.setCurrentUserId(user.id)&#10;        Result.success(user)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun updateProfile(name: String?, surname: String?): Result&lt;com.example.tuchanguito.network.dto.UserDTO&gt; = try {&#10;        val updated = api.auth.updateProfile(com.example.tuchanguito.network.dto.UserUpdateDTO(name = name, surname = surname))&#10;        prefs.setCurrentUserId(updated.id)&#10;        Result.success(updated)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // Products&#10;    fun categories(): Flow&lt;List&lt;Category&gt;&gt; = categoryDao.observeAll()&#10;    fun products(): Flow&lt;List&lt;Product&gt;&gt; = productDao.observeAll()&#10;    suspend fun upsertCategory(name: String) = categoryDao.upsert(Category(name = name))&#10;    suspend fun upsertProduct(product: Product) = productDao.upsert(product)&#10;    suspend fun deleteProduct(product: Product) = productDao.delete(product)&#10;&#10;    // Catalog sync with API&#10;    suspend fun syncCatalog(): Result&lt;Unit&gt; = try {&#10;        // Clear local snapshot before re-hydrating to avoid ghost data after API switch&#10;        categoryDao.clearAll()&#10;        productDao.clearAll()&#10;        // Categories&#10;        val catPage = api.catalog.getCategories(page = 1, perPage = 1000)&#10;        catPage.data.forEach { c -&gt;&#10;            categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name))&#10;        }&#10;        // Products&#10;        val prodPage = api.catalog.getProducts(page = 1, perPage = 1000)&#10;        prodPage.data.forEach { p -&gt;&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unit = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val catId = p.category?.id&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unit))&#10;        }&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    suspend fun createOrFindCategoryByName(name: String): Long {&#10;        val trimmed = name.trim()&#10;        // Try remote search&#10;        val found = runCatching { api.catalog.getCategories(name = trimmed, page = 1, perPage = 1) }.getOrNull()&#10;        val existing = found?.data?.firstOrNull { it.name.equals(trimmed, ignoreCase = true) }&#10;        if (existing != null) {&#10;            categoryDao.upsert(Category(id = existing.id ?: 0L, name = existing.name))&#10;            return existing.id ?: 0L&#10;        }&#10;        // Create&#10;        val created = api.catalog.createCategory(CategoryDTO(name = trimmed))&#10;        categoryDao.upsert(Category(id = created.id ?: 0L, name = created.name))&#10;        return created.id ?: 0L&#10;    }&#10;&#10;    suspend fun createProductRemote(name: String, price: Double, unit: String, categoryId: Long?): Long {&#10;        // Resolve category: if id came from local DB but doesn’t exist remotely, create it first&#10;        val finalCatId = if (categoryId != null) {&#10;            // Try to fetch remote category; if missing, create by local name fallback&#10;            val remoteOk = runCatching { api.catalog.getCategories(page = 1, perPage = 1000) }.getOrNull()?.data?.any { it.id == categoryId } == true&#10;            if (remoteOk) categoryId else {&#10;                // Try to read local name and recreate remotely&#10;                val localName = runCatching { categoryDao.getById(categoryId)?.name }.getOrNull()&#10;                if (!localName.isNullOrBlank()) createOrFindCategoryByName(localName) else categoryId&#10;            }&#10;        } else null&#10;&#10;        val resp = api.catalog.createProduct(&#10;            ProductRegistrationDTO(&#10;                name = name,&#10;                category = finalCatId?.let { IdRef(it) },&#10;                metadata = mapOf(&quot;price&quot; to price, &quot;unit&quot; to unit)&#10;            )&#10;        )&#10;        if (!resp.isSuccessful) {&#10;            // Attempt to find existing product with same name (409 Conflict case)&#10;            val page = runCatching { api.catalog.getProducts(name = name, page = 1, perPage = 1) }.getOrNull()&#10;            val existing = page?.data?.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;            if (existing != null) {&#10;                val exId = existing.id ?: 0L&#10;                val pPrice = (existing.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;                val pUnit = (existing.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;                productDao.upsert(Product(id = exId, name = existing.name, price = pPrice, categoryId = existing.category?.id, unit = pUnit))&#10;                return exId&#10;            }&#10;            throw IllegalStateException(&quot;Error creando producto: HTTP ${'$'}{resp.code()}&quot;)&#10;        }&#10;        // Some servers return minimal/empty body on create; fetch by name to locate the created product&#10;        val page = runCatching { api.catalog.getProducts(name = name, page = 1, perPage = 1) }.getOrNull()&#10;        val dto = page?.data?.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;            ?: throw IllegalStateException(&quot;Producto creado pero no encontrado por nombre&quot;)&#10;        val pId = dto.id ?: 0L&#10;        val pCatId = dto.category?.id&#10;        val pPrice = (dto.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;        val pUnit = (dto.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;        productDao.upsert(Product(id = pId, name = dto.name, price = pPrice, categoryId = pCatId, unit = pUnit))&#10;        // Ensure list shows all current remote products&#10;        syncProducts()&#10;        return pId&#10;    }&#10;&#10;    suspend fun updateProductRemote(id: Long, name: String, price: Double, unit: String, categoryId: Long?) {&#10;        val resp = api.catalog.updateProduct(&#10;            id,&#10;            ProductRegistrationDTO(&#10;                name = name,&#10;                category = categoryId?.let { IdRef(it) },&#10;                metadata = mapOf(&quot;price&quot; to price, &quot;unit&quot; to unit)&#10;            )&#10;        )&#10;        if (!resp.isSuccessful) {&#10;            throw IllegalStateException(&quot;Error actualizando producto: HTTP ${'$'}{resp.code()}&quot;)&#10;        }&#10;        // Regardless of body, fetch latest from server to ensure final state matches backend rules&#10;        val server = runCatching { api.catalog.getProduct(id) }.getOrNull()&#10;        val pCatId = server?.category?.id ?: categoryId&#10;        val pPrice = (server?.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: price&#10;        val pUnit = (server?.metadata?.get(&quot;unit&quot;) as? String).orEmpty().ifBlank { unit }&#10;        val pName = server?.name ?: name&#10;        productDao.upsert(Product(id = id, name = pName, price = pPrice, categoryId = pCatId, unit = pUnit))&#10;        // Refresh full list to avoid partial state&#10;        syncProducts()&#10;    }&#10;&#10;    suspend fun deleteProductRemote(id: Long) {&#10;        api.catalog.deleteProduct(id)&#10;        productDao.getById(id)?.let { productDao.delete(it) }&#10;        // Refresh remote to ensure local matches server after deletion&#10;        syncProducts()&#10;    }&#10;&#10;    private suspend fun syncProducts() {&#10;        runCatching { api.catalog.getProducts(page = 1, perPage = 1000) }&#10;            .onSuccess { page -&gt;&#10;                page.data.forEach { p -&gt;&#10;                    val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;                    val unit = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                    val catId = p.category?.id&#10;                    productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unit))&#10;                }&#10;            }&#10;    }&#10;&#10;    // Lists (API-backed)&#10;    fun activeLists(): Flow&lt;List&lt;ShoppingList&gt;&gt; = remoteLists&#10;    fun listById(id: Long): Flow&lt;ShoppingList?&gt; = listDao.observeById(id)&#10;    suspend fun loadListIntoLocal(id: Long) {&#10;        // Fetch remote list and persist into Room so UI detail observes correct title&#10;        runCatching { api.shopping.getList(id) }&#10;            .onSuccess { dto -&gt; listDao.upsert(ShoppingList(id = dto.id, title = dto.name)) }&#10;    }&#10;&#10;    suspend fun refreshLists(): Result&lt;Unit&gt; = try {&#10;        val page = api.shopping.getLists()&#10;        val lists = page.data.map { ShoppingList(id = it.id, title = it.name) }&#10;        _remoteLists.value = lists&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) {&#10;        // Keep previous cache and report failure without throwing&#10;        Result.failure(t)&#10;    }&#10;&#10;    private suspend fun existsListWithName(name: String): Boolean {&#10;        return try {&#10;            // Ask API filtering by name and owner=true to check uniqueness on server&#10;            val page = api.shopping.getLists(name = name, owner = true, page = 1, perPage = 1)&#10;            page.data.any { it.name.equals(name, ignoreCase = true) }&#10;        } catch (_: Throwable) { false }&#10;    }&#10;&#10;    suspend fun createList(title: String): Long {&#10;        // API requires name, description (string) and recurring (boolean)&#10;        // Prevent 409 UNIQUE constraint by checking server-side duplicates first&#10;        if (existsListWithName(title)) throw IllegalStateException(&quot;Ya existe una lista con ese nombre&quot;)&#10;        val dto = api.shopping.createList(&#10;            com.example.tuchanguito.network.dto.ShoppingListCreateDTO(&#10;                name = title,&#10;                description = &quot;&quot;,&#10;                recurring = false,&#10;                metadata = emptyMap()&#10;            )&#10;        )&#10;        // Fetch server version to ensure fields are in sync, then update cache&#10;        val created = runCatching { api.shopping.getList(dto.id) }.getOrNull()&#10;        val model = if (created != null) ShoppingList(id = created.id, title = created.name) else ShoppingList(id = dto.id, title = dto.name)&#10;        _remoteLists.update { it + model }&#10;        // Also persist in Room so ListDetail observes the correct title immediately&#10;        listDao.upsert(model)&#10;        return dto.id&#10;    }&#10;&#10;    suspend fun renameList(id: Long, newTitle: String) {&#10;        if (existsListWithName(newTitle)) throw IllegalStateException(&quot;Ya existe una lista con ese nombre&quot;)&#10;        api.shopping.updateList(id, com.example.tuchanguito.network.dto.ShoppingListCreateDTO(name = newTitle))&#10;        _remoteLists.update { cur -&gt; cur.map { if (it.id == id) it.copy(title = newTitle) else it } }&#10;        // Keep Room in sync so ListDetail shows the updated title&#10;        listDao.upsert(ShoppingList(id = id, title = newTitle))&#10;    }&#10;&#10;    suspend fun deleteListRemote(id: Long) {&#10;        api.shopping.deleteList(id)&#10;        _remoteLists.update { cur -&gt; cur.filterNot { it.id == id } }&#10;    }&#10;&#10;    fun itemsForList(listId: Long): Flow&lt;List&lt;ListItem&gt;&gt; = itemDao.observeForList(listId)&#10;&#10;    private suspend fun fetchListItemsEither(listId: Long): List&lt;ListItemDTO&gt; {&#10;        // Try plain array first&#10;        return runCatching { api.shopping.getItems(listId) }.getOrElse {&#10;            // Fallback to page-wrapped structure&#10;            runCatching { api.shopping.getItemsPage(listId).data }.getOrElse { emptyList() }&#10;        }&#10;    }&#10;&#10;    suspend fun fetchListItemsRemote(listId: Long): List&lt;ListItemDTO&gt; = fetchListItemsEither(listId)&#10;&#10;    // --- New: API-backed list item operations ---&#10;    suspend fun syncListItems(listId: Long) {&#10;        // Ensure list exists locally (FK for list_items)&#10;        runCatching { api.shopping.getList(listId) }.onSuccess { dto -&gt;&#10;            listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;        }&#10;        val remoteItems = fetchListItemsEither(listId)&#10;        remoteItems.forEach { li -&gt;&#10;            val p = li.product&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val existing = runCatching { productDao.getById(p.id ?: 0L) }.getOrNull()&#10;            var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;            var finalCatId = p.category?.id ?: existing?.categoryId&#10;            // Hydrate missing category/unit from product endpoint when needed&#10;            if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;                runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                    finalCatId = full.category?.id ?: finalCatId&#10;                    val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                    if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                }&#10;            }&#10;            p.category?.let { categoryDto -&gt;&#10;                categoryDao.upsert(Category(id = categoryDto.id ?: 0L, name = categoryDto.name))&#10;            }&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;            itemDao.upsert(&#10;                ListItem(&#10;                    id = li.id,&#10;                    listId = listId,&#10;                    productId = p.id ?: 0L,&#10;                    quantity = li.quantity.toInt(),&#10;                    acquired = li.purchased&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    suspend fun addItemRemote(listId: Long, productId: Long, quantity: Int = 1, unit: String = &quot;u&quot;): Long {&#10;        return try {&#10;            val resp = api.shopping.addItem(listId, com.example.tuchanguito.network.dto.ListItemCreateDTO(product = IdRef(productId), quantity = quantity.toDouble(), unit = unit))&#10;            if (!resp.isSuccessful) throw retrofit2.HttpException(resp)&#10;            runCatching { api.shopping.getList(listId) }.onSuccess { dto -&gt;&#10;                listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;            }&#10;            val remoteItems = fetchListItemsEither(listId)&#10;            remoteItems.forEach { li -&gt;&#10;                val p = li.product&#10;                val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;                val unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                val existing = runCatching { productDao.getById(p.id ?: 0L) }.getOrNull()&#10;                var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;                var finalCatId = p.category?.id ?: existing?.categoryId&#10;                if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;                    runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                        finalCatId = full.category?.id ?: finalCatId&#10;                        val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                        if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                    }&#10;                }&#10;                p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;                productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;                itemDao.upsert(ListItem(id = li.id, listId = listId, productId = p.id ?: 0L, quantity = li.quantity.toInt(), acquired = li.purchased))&#10;            }&#10;            remoteItems.firstOrNull { it.product.id == productId }?.id&#10;                ?: remoteItems.maxByOrNull { it.id }?.id&#10;                ?: 0L&#10;        } catch (t: Throwable) {&#10;            val code = (t as? retrofit2.HttpException)?.code()&#10;            if (code == 409) {&#10;                val remoteItems = runCatching { fetchListItemsEither(listId) }.getOrDefault(emptyList())&#10;                val existing = remoteItems.firstOrNull { it.product.id == productId }&#10;                if (existing != null) {&#10;                    val newQty = existing.quantity.toInt() + quantity&#10;                    val chosenUnit = existing.unit.ifBlank { unit }&#10;                    updateItemQuantityRemote(listId, existing.id, productId, newQty, chosenUnit)&#10;                    existing.id&#10;                } else {&#10;                    throw t&#10;                }&#10;            } else {&#10;                throw t&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun updateItemQuantityRemote(listId: Long, itemId: Long, productId: Long, newQuantity: Int, unit: String = &quot;u&quot;) {&#10;        val updated = api.shopping.updateItem(listId, itemId, com.example.tuchanguito.network.dto.ListItemCreateDTO(product = IdRef(productId), quantity = newQuantity.toDouble(), unit = unit))&#10;        val p = updated.product&#10;        val existing = runCatching { productDao.getById(p.id ?: productId) }.getOrNull()&#10;        var price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: (existing?.price ?: 0.0)&#10;        var unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        var finalUnit = unitFromServer.ifBlank { existing?.unit ?: unit }&#10;        var finalCatId = p.category?.id ?: existing?.categoryId&#10;        if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;            runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                finalCatId = full.category?.id ?: finalCatId&#10;                val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                val pr = (full.metadata?.get(&quot;price&quot;) as? Number)?.toDouble()&#10;                if (pr != null) price = pr&#10;            }&#10;        }&#10;        p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        productDao.upsert(Product(id = p.id ?: productId, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;        itemDao.upsert(&#10;            ListItem(&#10;                id = updated.id,&#10;                listId = listId,&#10;                productId = updated.product.id ?: productId,&#10;                quantity = updated.quantity.toInt(),&#10;                acquired = updated.purchased&#10;            )&#10;        )&#10;    }&#10;&#10;    suspend fun toggleItemPurchasedRemote(listId: Long, itemId: Long, purchased: Boolean) {&#10;        val updated = api.shoppingPatch.togglePurchased(listId, itemId, mapOf(&quot;purchased&quot; to purchased))&#10;        val p = updated.product&#10;        val pId = p.id ?: 0L&#10;        val existing = runCatching { productDao.getById(pId) }.getOrNull()&#10;        var price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: (existing?.price ?: 0.0)&#10;        var unitFromServer = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        var finalUnit = unitFromServer.ifBlank { existing?.unit ?: &quot;&quot; }&#10;        var finalCatId = p.category?.id ?: existing?.categoryId&#10;        if ((finalCatId == null || finalUnit.isBlank()) &amp;&amp; (p.id != null)) {&#10;            runCatching { api.catalog.getProduct(p.id!!) }.onSuccess { full -&gt;&#10;                finalCatId = full.category?.id ?: finalCatId&#10;                val u = (full.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;                if (finalUnit.isBlank() &amp;&amp; u.isNotBlank()) finalUnit = u&#10;                val pr = (full.metadata?.get(&quot;price&quot;) as? Number)?.toDouble()&#10;                if (pr != null) price = pr&#10;            }&#10;        }&#10;        p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        productDao.upsert(Product(id = pId, name = p.name, price = price, categoryId = finalCatId, unit = finalUnit))&#10;        itemDao.upsert(ListItem(id = updated.id, listId = listId, productId = pId, quantity = updated.quantity.toInt(), acquired = updated.purchased))&#10;    }&#10;&#10;    suspend fun deleteItemRemote(listId: Long, itemId: Long, local: ListItem? = null) {&#10;        // Delete from server; ignore body&#10;        runCatching { api.shopping.deleteItem(listId, itemId) }&#10;            .onFailure { throw it }&#10;        // Remove local row by id (or provided entity) to keep Room in sync immediately&#10;        if (local != null) {&#10;            runCatching { itemDao.delete(local) }&#10;        }&#10;        runCatching { itemDao.deleteById(itemId) }&#10;        // Optionally refresh items from server to ensure correct state (quantities of other items may change)&#10;        runCatching { syncListItems(listId) }&#10;    }&#10;&#10;    suspend fun deleteItemByIdLocal(id: Long) = itemDao.deleteById(id)&#10;&#10;    // Local-only fallbacks preserved&#10;    suspend fun addItem(listId: Long, productId: Long, quantity: Int = 1) = itemDao.upsert(ListItem(listId = listId, productId = productId, quantity = quantity))&#10;    suspend fun updateItem(item: ListItem) = itemDao.update(item)&#10;    suspend fun removeItem(item: ListItem) = itemDao.delete(item)&#10;&#10;    // Pantry&#10;    fun pantry(): Flow&lt;List&lt;PantryItem&gt;&gt; = pantryDao.observeAll()&#10;&#10;    private suspend fun isPantryUsable(id: Long): Boolean {&#10;        return runCatching {&#10;            api.pantry.getItems(id, page = 1, perPage = 1)&#10;            true&#10;        }.getOrDefault(false)&#10;    }&#10;&#10;    suspend fun ensureDefaultPantryId(): Long {&#10;        // Evitar llamadas repetidas: si tenemos cache en memoria, devolverla&#10;        cachedPantryId?.let { return it }&#10;        // Intentar recuperar la última alacena usada sin sondear el endpoint de items&#10;        val saved = runCatching { prefs.currentPantryId.first() }.getOrNull()&#10;        if (saved != null) {&#10;            cachedPantryId = saved&#10;            return saved&#10;        }&#10;        // No hay guardada: crear una nueva alacena inmediatamente (evitamos escanear y sondear)&#10;        val created = runCatching { api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena&quot;)) }&#10;            .getOrElse {&#10;                // Nombre alternativo para evitar conflicto si ya existe&#10;                api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena ${System.currentTimeMillis() % 10000}&quot;))&#10;            }&#10;        runCatching { prefs.setCurrentPantryId(created.id) }&#10;        cachedPantryId = created.id&#10;        return created.id&#10;    }&#10;&#10;    private suspend fun createFreshPantry(): Long {&#10;        // Try default name; if conflict, suffix with timestamp fragment&#10;        val tryNames = listOf(&quot;Alacena&quot;, &quot;Alacena ${System.currentTimeMillis() % 10000}&quot;)&#10;        for (n in tryNames) {&#10;            val created = runCatching { api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = n)) }.getOrNull()&#10;            if (created != null) return created.id&#10;        }&#10;        // Last resort&#10;        val fallback = api.pantry.createPantry(com.example.tuchanguito.network.dto.PantryCreateDTO(name = &quot;Alacena ${System.currentTimeMillis()}&quot;))&#10;        return fallback.id&#10;    }&#10;&#10;    suspend fun syncPantry(search: String? = null, categoryId: Long? = null) {&#10;        var pantryId = ensureDefaultPantryId()&#10;        // Reset local mirror before rehydrating from server to avoid stale/corrupt rows from a previous pantry&#10;        runCatching { pantryDao.clearAll() }&#10;        var page = runCatching { api.pantry.getItems(pantryId, search = search, categoryId = categoryId, page = 1, perPage = 1000, sortBy = &quot;productName&quot;, order = &quot;DESC&quot;) }.getOrNull()&#10;        if (page == null) {&#10;            // The selected pantry is not usable (backend 500). Create a fresh pantry and retry once.&#10;            pantryId = runCatching { createFreshPantry() }.getOrElse { pantryId }&#10;            runCatching { prefs.setCurrentPantryId(pantryId) }&#10;            page = runCatching { api.pantry.getItems(pantryId, search = search, categoryId = categoryId, page = 1, perPage = 1000, sortBy = &quot;productName&quot;, order = &quot;DESC&quot;) }.getOrNull()&#10;            if (page == null) return // fail silently to avoid crashing UI&#10;        }&#10;        val items = page.data&#10;        // Upsert products/categories and mirror pantry items&#10;        items.forEach { it -&gt;&#10;            val p = it.product&#10;            val price = (p.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;            val unitMeta = (p.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;            val catId = p.category?.id&#10;            p.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;            productDao.upsert(Product(id = p.id ?: 0L, name = p.name, price = price, categoryId = catId, unit = unitMeta))&#10;            pantryDao.upsert(PantryItem(id = it.id, productId = p.id ?: 0L, quantity = it.quantity.toInt()))&#10;        }&#10;    }&#10;&#10;    suspend fun addPantryItem(productId: Long, quantity: Int, unit: String = &quot;u&quot;) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        val created = api.pantry.addItem(pantryId, com.example.tuchanguito.network.dto.PantryItemCreateDTO(product = com.example.tuchanguito.network.dto.IdRef(productId), quantity = quantity.toDouble(), unit = unit))&#10;        // Upsert related product/category then mirror item&#10;        created.product.category?.let { c -&gt; categoryDao.upsert(Category(id = c.id ?: 0L, name = c.name)) }&#10;        val pPrice = (created.product.metadata?.get(&quot;price&quot;) as? Number)?.toDouble() ?: 0.0&#10;        val pUnit = (created.product.metadata?.get(&quot;unit&quot;) as? String).orEmpty()&#10;        productDao.upsert(Product(id = created.product.id ?: productId, name = created.product.name, price = pPrice, categoryId = created.product.category?.id, unit = pUnit))&#10;        pantryDao.upsert(PantryItem(id = created.id, productId = created.product.id ?: productId, quantity = created.quantity.toInt()))&#10;    }&#10;&#10;    // Add-or-increment pantry item if a row for the same product already exists&#10;    suspend fun addOrIncrementPantryItem(productId: Long, addQuantity: Int, unit: String = &quot;u&quot;) {&#10;        // First ensure we have current pantry snapshot locally&#10;        runCatching { syncPantry() }&#10;        val existing = pantryDao.findByProduct(productId)&#10;        if (existing != null) {&#10;            // Update quantity via API using existing item id&#10;            updatePantryItem(existing.id, existing.quantity + addQuantity, unit)&#10;        } else {&#10;            addPantryItem(productId, addQuantity, unit)&#10;        }&#10;    }&#10;&#10;    suspend fun updatePantryItem(itemId: Long, quantity: Int, unit: String = &quot;u&quot;) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        val updated = api.pantry.updateItem(pantryId, itemId, com.example.tuchanguito.network.dto.PantryItemUpdateDTO(quantity = quantity.toDouble(), unit = unit))&#10;        pantryDao.upsert(PantryItem(id = updated.id, productId = updated.product.id ?: 0L, quantity = updated.quantity.toInt()))&#10;    }&#10;&#10;    suspend fun deletePantryItem(itemId: Long) {&#10;        val pantryId = ensureDefaultPantryId()&#10;        runCatching { api.pantry.deleteItem(pantryId, itemId) }&#10;            .onFailure { throw it }&#10;        // Clean local row safely by id&#10;        runCatching { pantryDao.deleteById(itemId) }&#10;        // Refresh to ensure UI consistent&#10;        runCatching { syncPantry() }&#10;    }&#10;&#10;    // Validate Credentials&#10;    suspend fun validateCredentials(email: String, password: String): Result&lt;Unit&gt; = try {&#10;        api.auth.login(com.example.tuchanguito.network.dto.CredentialsDTO(email, password))&#10;        Result.success(Unit)&#10;    } catch (t: Throwable) { Result.failure(t) }&#10;&#10;    // --- Backend-driven product search helpers for ProductsScreen ---&#10;    suspend fun searchProductsDTO(name: String?, categoryId: Long?): List&lt;ProductDTO&gt; {&#10;        val page = api.catalog.getProducts(name = name?.takeIf { it.isNotBlank() }, categoryId = categoryId, page = 1, perPage = 1000)&#10;        return page.data&#10;    }&#10;&#10;    suspend fun categoriesForQuery(name: String?): List&lt;CategoryDTO&gt; {&#10;        val page = api.catalog.getProducts(name = name?.takeIf { it.isNotBlank() }, categoryId = null, page = 1, perPage = 1000)&#10;        val distinct = LinkedHashMap&lt;Long, CategoryDTO&gt;()&#10;        page.data.forEach { p -&gt;&#10;            val c = p.category&#10;            if (c?.id != null &amp;&amp; !distinct.containsKey(c.id!!)) distinct[c.id!!] = CategoryDTO(id = c.id, name = c.name, metadata = c.metadata)&#10;        }&#10;        return distinct.values.toList().sortedBy { it.name.lowercase() }&#10;    }&#10;&#10;    // --- New: share shopping list with user by email ---&#10;    suspend fun shareListRemote(listId: Long, email: String) {&#10;        val dto = api.shopping.shareList(listId, com.example.tuchanguito.network.dto.ShareRequestDTO(email))&#10;        // Update local Room title (still the same name) and refresh remote lists so the shared user view is consistent&#10;        listDao.upsert(ShoppingList(id = dto.id, title = dto.name))&#10;        runCatching { refreshLists() }&#10;    }&#10;&#10;    // --- Pantry helpers for backend-driven filtering ---&#10;    suspend fun pantryCategoriesForQuery(name: String?): List&lt;com.example.tuchanguito.network.dto.CategoryDTO&gt; {&#10;        val pantryId = ensureDefaultPantryId()&#10;        val page = runCatching {&#10;            api.pantry.getItems(&#10;                pantryId,&#10;                search = name?.takeIf { it.isNotBlank() },&#10;                categoryId = null,&#10;                page = 1,&#10;                perPage = 1000,&#10;                sortBy = &quot;productName&quot;,&#10;                order = &quot;ASC&quot;&#10;            )&#10;        }.getOrNull()&#10;        val distinct = LinkedHashMap&lt;Long, com.example.tuchanguito.network.dto.CategoryDTO&gt;()&#10;        page?.data.orEmpty().forEach { it -&gt;&#10;            val c = it.product.category&#10;            val id = c?.id&#10;            if (id != null &amp;&amp; !distinct.containsKey(id)) {&#10;                distinct[id] = com.example.tuchanguito.network.dto.CategoryDTO(id = id, name = c.name, metadata = c.metadata)&#10;            }&#10;        }&#10;        return distinct.values.toList().sortedBy { it.name.lowercase() }&#10;    }&#10;&#10;    companion object {&#10;        @Volatile private var INSTANCE: AppRepository? = null&#10;        fun get(context: Context): AppRepository = INSTANCE ?: synchronized(this) {&#10;            INSTANCE ?: AppRepository(context.applicationContext).also { INSTANCE = it }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/network/service/ShoppingService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/network/service/ShoppingService.kt" />
              <option name="originalContent" value="package com.example.tuchanguito.network.service&#10;&#10;import com.example.tuchanguito.network.dto.*&#10;import retrofit2.http.*&#10;import retrofit2.Response&#10;&#10;interface ShoppingService {&#10;    // Lists&#10;    @GET(&quot;api/shopping-lists&quot;)&#10;    suspend fun getLists(&#10;        @Query(&quot;name&quot;) name: String? = null,&#10;        @Query(&quot;owner&quot;) owner: Boolean? = null,&#10;        @Query(&quot;recurring&quot;) recurring: Boolean? = null,&#10;        @Query(&quot;page&quot;) page: Int? = null,&#10;        @Query(&quot;per_page&quot;) perPage: Int? = null,&#10;        @Query(&quot;sort_by&quot;) sortBy: String? = null,&#10;        @Query(&quot;order&quot;) order: String? = null,&#10;    ): PageDTO&lt;ShoppingListDTO&gt;&#10;&#10;    @GET(&quot;api/shopping-lists/{id}&quot;) suspend fun getList(@Path(&quot;id&quot;) id: Long): ShoppingListDTO&#10;    @POST(&quot;api/shopping-lists&quot;) suspend fun createList(@Body body: ShoppingListCreateDTO): ShoppingListDTO&#10;    @PUT(&quot;api/shopping-lists/{id}&quot;) suspend fun updateList(@Path(&quot;id&quot;) id: Long, @Body body: ShoppingListCreateDTO): ShoppingListDTO&#10;    @DELETE(&quot;api/shopping-lists/{id}&quot;) suspend fun deleteList(@Path(&quot;id&quot;) id: Long)&#10;&#10;    // --- New: share list ---&#10;    @POST(&quot;api/shopping-lists/{id}/share&quot;)&#10;    suspend fun shareList(@Path(&quot;id&quot;) listId: Long, @Body body: ShareRequestDTO): ShoppingListDTO&#10;&#10;    // Items&#10;    @GET(&quot;api/shopping-lists/{id}/items&quot;) suspend fun getItems(@Path(&quot;id&quot;) listId: Long): List&lt;ListItemDTO&gt;&#10;&#10;    // Fallback: some servers may wrap the array in an object with `data`&#10;    @GET(&quot;api/shopping-lists/{id}/items&quot;) suspend fun getItemsPage(@Path(&quot;id&quot;) listId: Long): PageDTO&lt;ListItemDTO&gt;&#10;&#10;    @POST(&quot;api/shopping-lists/{id}/items&quot;) suspend fun addItem(@Path(&quot;id&quot;) listId: Long, @Body body: ListItemCreateDTO): Response&lt;Unit&gt;&#10;    @PUT(&quot;api/shopping-lists/{id}/items/{item_id}&quot;) suspend fun updateItem(@Path(&quot;id&quot;) listId: Long, @Path(&quot;item_id&quot;) itemId: Long, @Body body: ListItemCreateDTO): ListItemDTO&#10;    @DELETE(&quot;api/shopping-lists/{id}/items/{item_id}&quot;) suspend fun deleteItem(@Path(&quot;id&quot;) listId: Long, @Path(&quot;item_id&quot;) itemId: Long)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.tuchanguito.network.service&#10;&#10;import com.example.tuchanguito.network.dto.*&#10;import retrofit2.http.*&#10;import retrofit2.Response&#10;&#10;interface ShoppingService {&#10;    // Lists&#10;    @GET(&quot;api/shopping-lists&quot;)&#10;    suspend fun getLists(&#10;        @Query(&quot;name&quot;) name: String? = null,&#10;        @Query(&quot;owner&quot;) owner: Boolean? = null,&#10;        @Query(&quot;recurring&quot;) recurring: Boolean? = null,&#10;        @Query(&quot;page&quot;) page: Int? = null,&#10;        @Query(&quot;per_page&quot;) perPage: Int? = null,&#10;        @Query(&quot;sort_by&quot;) sortBy: String? = null,&#10;        @Query(&quot;order&quot;) order: String? = null,&#10;    ): PageDTO&lt;ShoppingListDTO&gt;&#10;&#10;    @GET(&quot;api/shopping-lists/{id}&quot;) suspend fun getList(@Path(&quot;id&quot;) id: Long): ShoppingListDTO&#10;    @POST(&quot;api/shopping-lists&quot;) suspend fun createList(@Body body: ShoppingListCreateDTO): ShoppingListDTO&#10;    @PUT(&quot;api/shopping-lists/{id}&quot;) suspend fun updateList(@Path(&quot;id&quot;) id: Long, @Body body: ShoppingListCreateDTO): ShoppingListDTO&#10;    @DELETE(&quot;api/shopping-lists/{id}&quot;) suspend fun deleteList(@Path(&quot;id&quot;) id: Long)&#10;&#10;    // --- New: share list ---&#10;    @POST(&quot;api/shopping-lists/{id}/share&quot;)&#10;    suspend fun shareList(@Path(&quot;id&quot;) listId: Long, @Body body: ShareRequestDTO): ShoppingListDTO&#10;&#10;    // Items&#10;    @GET(&quot;api/shopping-lists/{id}/items&quot;) suspend fun getItems(@Path(&quot;id&quot;) listId: Long): List&lt;ListItemDTO&gt;&#10;&#10;    // Fallback: some servers may wrap the array in an object with `data`&#10;    @GET(&quot;api/shopping-lists/{id}/items&quot;) suspend fun getItemsPage(@Path(&quot;id&quot;) listId: Long): PageDTO&lt;ListItemDTO&gt;&#10;&#10;    @POST(&quot;api/shopping-lists/{id}/items&quot;) suspend fun addItem(@Path(&quot;id&quot;) listId: Long, @Body body: ListItemCreateDTO): Response&lt;Unit&gt;&#10;    @PUT(&quot;api/shopping-lists/{id}/items/{item_id}&quot;) suspend fun updateItem(@Path(&quot;id&quot;) listId: Long, @Path(&quot;item_id&quot;) itemId: Long, @Body body: ListItemCreateDTO): ListItemDTO&#10;    @DELETE(&quot;api/shopping-lists/{id}/items/{item_id}&quot;) suspend fun deleteItem(@Path(&quot;id&quot;) listId: Long, @Path(&quot;item_id&quot;) itemId: Long)&#10;&#10;    // --- New: move purchased items to pantry (owner-only) ---&#10;    @POST(&quot;api/shopping-lists/{id}/move-to-pantry&quot;)&#10;    suspend fun moveToPantry(@Path(&quot;id&quot;) listId: Long): List&lt;PantryItemDTO&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/screens/lists/ListDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/screens/lists/ListDetailScreen.kt" />
              <option name="originalContent" value="package com.example.tuchanguito.ui.screens.lists&#10;&#10;import android.content.Intent&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.ContentCopy&#10;import androidx.compose.material.icons.filled.Share&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.unit.dp&#10;import com.example.tuchanguito.data.AppRepository&#10;import com.example.tuchanguito.data.model.ListItem&#10;import com.example.tuchanguito.data.model.Product&#10;import com.example.tuchanguito.network.dto.ListItemDTO&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import retrofit2.HttpException&#10;import androidx.compose.ui.platform.LocalFocusManager&#10;import java.net.SocketTimeoutException&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ListDetailScreen(listId: Long, onClose: () -&gt; Unit = {}) {&#10;    val context = LocalContext.current&#10;    val repo = remember { AppRepository.get(context) }&#10;    val list by repo.listById(listId).collectAsState(initial = null)&#10;    val listItems by repo.itemsForList(listId).collectAsState(initial = emptyList())&#10;    val products by repo.products().collectAsState(initial = emptyList())&#10;    val categories by repo.categories().collectAsState(initial = emptyList())&#10;    val scope = rememberCoroutineScope()&#10;    val snack = remember { SnackbarHostState() }&#10;&#10;    // Remote-backed fallback for items&#10;    var remoteItems by remember { mutableStateOf&lt;List&lt;ListItemDTO&gt;&gt;(emptyList()) }&#10;&#10;    // Initial sync from backend so detail shows server data&#10;    LaunchedEffect(listId) {&#10;        repo.loadListIntoLocal(listId)&#10;        runCatching { repo.syncCatalog() }&#10;        runCatching { repo.syncListItems(listId) }&#10;        // Keep a remote snapshot once for fallback rendering&#10;        remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;    }&#10;&#10;    // Helper maps&#10;    val productById = remember(products) { products.associateBy { it.id } }&#10;    val remoteByProductId = remember(remoteItems) { remoteItems.associateBy { it.product.id ?: -1L } }&#10;    val categoryById = remember(categories) { categories.associateBy { it.id } }&#10;&#10;    // Choose source for UI&#10;    val uiProducts: List&lt;Long&gt; = remember(listItems, remoteItems) {&#10;        if (listItems.isNotEmpty()) listItems.map { it.productId } else remoteItems.map { it.product.id ?: -1L }&#10;    }&#10;&#10;    val total = remember(uiProducts, products, listItems, remoteItems) {&#10;        uiProducts.sumOf { pid -&gt;&#10;            val qty = listItems.firstOrNull { it.productId == pid }?.quantity&#10;                ?: remoteByProductId[pid]?.quantity?.toInt()&#10;                ?: 0&#10;            val price = productById[pid]?.price ?: 0.0&#10;            (price * qty).toInt()&#10;        }&#10;    }&#10;&#10;    var showAdd by remember { mutableStateOf(false) }&#10;    var showFinalize by remember { mutableStateOf(false) }&#10;    var showShare by remember { mutableStateOf(false) }&#10;    var shareBusy by remember { mutableStateOf(false) }&#10;    var shareMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var shareIsError by remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(title = { Text(list?.title ?: &quot;Lista&quot;) }, actions = {&#10;                IconButton(onClick = {&#10;                    // Share list via app share sheet (copy text)&#10;                    val body = buildString {&#10;                        appendLine(list?.title ?: &quot;Lista&quot;)&#10;                        appendLine()&#10;                        listItems.forEach { li -&gt;&#10;                            val prod = products.firstOrNull { it.id == li.productId }&#10;                            appendLine(&quot;- ${prod?.name ?: &quot;Producto&quot;} x${li.quantity}&quot;)&#10;                        }&#10;                        appendLine()&#10;                        append(&quot;Total: \$${total}&quot;)&#10;                    }&#10;                    val send = Intent(Intent.ACTION_SEND).apply { type = &quot;text/plain&quot;; putExtra(Intent.EXTRA_TEXT, body) }&#10;                    context.startActivity(Intent.createChooser(send, &quot;Compartir lista&quot;))&#10;                }) { Icon(Icons.Default.ContentCopy, contentDescription = &quot;Copiar contenido de la lista&quot;) }&#10;                IconButton(onClick = {&#10;                    // Reset message state each time dialog opens&#10;                    shareMessage = null&#10;                    shareIsError = false&#10;                    showShare = true&#10;                }) {&#10;                    Icon(Icons.Default.Share, contentDescription = &quot;Compartir lista con usuario&quot;)&#10;                }&#10;            })&#10;        },&#10;        snackbarHost = { SnackbarHost(hostState = snack) },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = { showAdd = true }) { Icon(Icons.Default.Add, contentDescription = null) }&#10;        }&#10;    ) { padding -&gt;&#10;        Column(Modifier.fillMaxSize().padding(padding)) {&#10;            // Group by local categoryId, falling back to remote product.category.id&#10;            val grouped = remember(uiProducts, products, remoteItems) {&#10;                uiProducts.groupBy { pid -&gt;&#10;                    productById[pid]?.categoryId ?: remoteByProductId[pid]?.product?.category?.id&#10;                }&#10;            }&#10;            LazyColumn(Modifier.weight(1f)) {&#10;                grouped.forEach { (catId, pids) -&gt;&#10;                    val catName = categories.firstOrNull { it.id == catId }?.name&#10;                        ?: pids.firstOrNull()?.let { firstPid -&gt;&#10;                            remoteByProductId[firstPid]?.product?.category?.name&#10;                        }&#10;                        ?: &quot;Sin categoría&quot;&#10;                    item(key = &quot;header-$catId&quot;) { Text(catName, style = MaterialTheme.typography.titleMedium, modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)) }&#10;                    items(pids, key = { it }) { pid -&gt;&#10;                        val product = productById[pid]&#10;                        val local = listItems.firstOrNull { it.productId == pid }&#10;                        val remote = remoteByProductId[pid]&#10;                        val qty = local?.quantity ?: remote?.quantity?.toInt() ?: 0&#10;                        val itemForRow = local ?: ListItem(&#10;                            id = remote?.id ?: 0L,&#10;                            listId = listId,&#10;                            productId = pid,&#10;                            quantity = qty,&#10;                            acquired = remote?.purchased ?: false&#10;                        )&#10;                        val unit = product?.unit?.ifBlank { remote?.unit ?: &quot;u&quot; } ?: (remote?.unit ?: &quot;u&quot;)&#10;                        ListRow(&#10;                            productName = product?.name ?: remote?.product?.name ?: &quot;Producto&quot;,&#10;                            price = product?.price ?: 0.0,&#10;                            unit = unit,&#10;                            item = itemForRow,&#10;                            onInc = {&#10;                                val existingId = local?.id ?: remote?.id&#10;                                scope.launch {&#10;                                    try {&#10;                                        if (existingId != null &amp;&amp; existingId &gt; 0) {&#10;                                            repo.updateItemQuantityRemote(listId, existingId, pid, qty + 1, unit)&#10;                                        } else {&#10;                                            repo.addItemRemote(listId, pid, (qty + 1).coerceAtLeast(1), unit)&#10;                                        }&#10;                                        // Fetch a single fresh snapshot for remote fallback&#10;                                        remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                                    } catch (t: Throwable) {&#10;                                        snack.showSnackbar(t.message ?: &quot;No se pudo actualizar la cantidad&quot;)&#10;                                    }&#10;                                }&#10;                            },&#10;                            onDec = {&#10;                                if (qty &gt; 1) {&#10;                                    val existingId = local?.id ?: remote?.id&#10;                                    if (existingId != null &amp;&amp; existingId &gt; 0) {&#10;                                        scope.launch {&#10;                                            try {&#10;                                                repo.updateItemQuantityRemote(listId, existingId, pid, qty - 1, unit)&#10;                                                remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                                            } catch (t: Throwable) {&#10;                                                snack.showSnackbar(t.message ?: &quot;No se pudo actualizar la cantidad&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            },&#10;                            onDelete = {&#10;                                val existingId = local?.id ?: remote?.id&#10;                                if (existingId != null &amp;&amp; existingId &gt; 0) {&#10;                                    scope.launch {&#10;                                        try {&#10;                                            if (local != null) repo.deleteItemRemote(listId, existingId, local) else runCatching { repo.deleteItemRemote(listId, existingId, ListItem(id = existingId, listId = listId, productId = pid, quantity = qty)) }&#10;                                            // Single refresh for fallback&#10;                                            remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                                        } catch (t: Throwable) {&#10;                                            snack.showSnackbar(t.message ?: &quot;No se pudo eliminar el producto de la lista&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            },&#10;                            onToggleAcquired = {&#10;                                val existingId = local?.id ?: remote?.id&#10;                                if (existingId != null &amp;&amp; existingId &gt; 0) {&#10;                                    val newPurchased = !(local?.acquired ?: (remote?.purchased ?: false))&#10;                                    scope.launch {&#10;                                        try {&#10;                                            repo.toggleItemPurchasedRemote(listId, existingId, newPurchased)&#10;                                            remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                                        } catch (t: Throwable) {&#10;                                            snack.showSnackbar(t.message ?: &quot;No se pudo cambiar el estado&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            Text(&quot;Costo total: \$${total}&quot;, style = MaterialTheme.typography.headlineSmall, modifier = Modifier.padding(16.dp))&#10;            // Reserve space at end for the floating action button (approx 72-88dp)&#10;            Row(&#10;                Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, end = 88.dp, bottom = 16.dp, top = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                OutlinedButton(&#10;                    onClick = onClose,&#10;                    modifier = Modifier&#10;                        .weight(0.45f)&#10;                        .heightIn(min = 36.dp)&#10;                ) { Text(&quot;Cerrar lista&quot;) }&#10;                Button(&#10;                    onClick = { showFinalize = true },&#10;                    modifier = Modifier&#10;                        .weight(0.45f)&#10;                        .heightIn(min = 36.dp)&#10;                ) { Text(&quot;Finalizar&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAdd) {&#10;        AddItemDialog(&#10;            products = products,&#10;            onDismiss = { showAdd = false },&#10;            onAdd = { productId, name, price, unit, categoryName -&gt;&#10;                scope.launch {&#10;                    try {&#10;                        val chosenProductId: Long = productId ?: run {&#10;                            val catId = categoryName?.let { if (it.isNotBlank()) repo.createOrFindCategoryByName(it) else null }&#10;                            repo.createProductRemote(name!!.trim(), price ?: 0.0, unit ?: &quot;u&quot;, catId)&#10;                        }&#10;                        if (productId != null) {&#10;                            val existing = products.firstOrNull { it.id == productId }&#10;                            val existingCategoryName = existing?.categoryId?.let { cid -&gt; categoryById[cid]?.name }&#10;                            val changedName = !name.isNullOrBlank()&#10;                            val changedPrice = price != null&#10;                            val changedUnit = !unit.isNullOrBlank() &amp;&amp; unit != existing?.unit&#10;                            val changedCategory = !categoryName.isNullOrBlank() &amp;&amp; !categoryName.equals(existingCategoryName, ignoreCase = true)&#10;                            if (changedName || changedPrice || changedUnit || changedCategory) {&#10;                                val catId = if (changedCategory) repo.createOrFindCategoryByName(categoryName) else existing?.categoryId&#10;                                repo.updateProductRemote(&#10;                                    id = productId,&#10;                                    name = name ?: existing?.name ?: &quot;&quot;,&#10;                                    price = price ?: existing?.price ?: 0.0,&#10;                                    unit = unit ?: existing?.unit ?: &quot;u&quot;,&#10;                                    categoryId = catId&#10;                                )&#10;                            }&#10;                        }&#10;                        val fallbackUnit = products.firstOrNull { it.id == chosenProductId }?.unit?.ifBlank { &quot;u&quot; } ?: &quot;u&quot;&#10;                        val safeUnitForItem = (unit?.takeIf { it.isNotBlank() } ?: fallbackUnit)&#10;                        repo.addItemRemote(listId, chosenProductId, 1, safeUnitForItem)&#10;                        // Single remote refresh for fallback&#10;                        remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                        showAdd = false&#10;                    } catch (t: Throwable) {&#10;                        snack.showSnackbar(t.message ?: &quot;No se pudo agregar el producto a la lista&quot;)&#10;                    }&#10;                }&#10;            },&#10;            onPrefillFor = { pid -&gt; products.firstOrNull { it.id == pid } },&#10;            categoryNameFor = { pid -&gt;&#10;                val prod = products.firstOrNull { it.id == pid }&#10;                prod?.categoryId?.let { cid -&gt; categoryById[cid]?.name }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showShare) {&#10;        ShareListDialog(&#10;            busy = shareBusy,&#10;            message = shareMessage,&#10;            isError = shareIsError,&#10;            onDismiss = {&#10;                if (!shareBusy) {&#10;                    showShare = false&#10;                    shareMessage = null&#10;                    shareIsError = false&#10;                }&#10;            },&#10;            onShare = { email -&gt;&#10;                if (shareBusy) return@ShareListDialog&#10;                shareBusy = true&#10;                shareMessage = null&#10;                shareIsError = false&#10;                scope.launch {&#10;                    try {&#10;                        repo.shareListRemote(listId, email)&#10;                        // Success: show concise success message&#10;                        shareMessage = &quot;La lista ha sido compartida&quot;&#10;                        shareIsError = false&#10;                    } catch (t: Throwable) {&#10;                        // If it's a network timeout, optimistically report success because the server may have processed it&#10;                        val isTimeout = t is SocketTimeoutException || (t.message?.contains(&quot;timeout&quot;, ignoreCase = true) == true)&#10;                        if (isTimeout) {&#10;                            shareMessage = &quot;La lista ha sido compartida&quot;&#10;                            shareIsError = false&#10;                        } else {&#10;                            val code = (t as? HttpException)?.code()&#10;                            val msg = when (code) {&#10;                                404 -&gt; &quot;No encontramos un usuario registrado con ese email&quot;&#10;                                409 -&gt; &quot;Ya compartiste esta lista con ese email&quot;&#10;                                400 -&gt; &quot;No se pudo compartir la lista. Verifica el email.&quot;&#10;                                401, 403 -&gt; &quot;No estás autorizado para realizar esta acción&quot;&#10;                                else -&gt; t.message ?: &quot;No se pudo compartir la lista&quot;&#10;                            }&#10;                            shareMessage = msg&#10;                            shareIsError = true&#10;                        }&#10;                    } finally {&#10;                        shareBusy = false&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // --- Finalize dialog state and UI ---&#10;    var finalizing by remember { mutableStateOf(false) }&#10;&#10;    // Replace Finalizar button onClick to open dialog&#10;    LaunchedEffect(Unit) {&#10;        // no-op placeholder to satisfy tool insertion constraints&#10;    }&#10;&#10;    if (showFinalize) {&#10;        FinalizeDialog(&#10;            listId = listId,&#10;            itemsProvider = {&#10;                // Always fetch a fresh snapshot from server to ensure accurate purchased flags&#10;                try { repo.fetchListItemsRemote(listId) } catch (_: Throwable) { remoteItems }&#10;            },&#10;            repo = repo,&#10;            onDismiss = { if (!finalizing) showFinalize = false },&#10;            onDone = { showFinalize = false; onClose() }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ListRow(&#10;    productName: String,&#10;    price: Double,&#10;    unit: String,&#10;    item: ListItem,&#10;    onInc: () -&gt; Unit,&#10;    onDec: () -&gt; Unit,&#10;    onDelete: () -&gt; Unit,&#10;    onToggleAcquired: () -&gt; Unit&#10;) {&#10;    ListItem(&#10;        leadingContent = {&#10;            Checkbox(checked = item.acquired, onCheckedChange = { onToggleAcquired() })&#10;        },&#10;        headlineContent = { Text(productName) },&#10;        supportingContent = { Text(&quot;\$${price} · ${unit} x ${item.quantity}&quot;) },&#10;        trailingContent = {&#10;            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                TextButton(onClick = onDec) { Text(&quot;-&quot;) }&#10;                Text(&quot;${item.quantity}&quot;)&#10;                TextButton(onClick = onInc) { Text(&quot;+&quot;) }&#10;                IconButton(onClick = onDelete) { Icon(Icons.Default.Delete, contentDescription = null) }&#10;            }&#10;        },&#10;        modifier = Modifier.fillMaxWidth()&#10;    )&#10;    HorizontalDivider()&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun AddItemDialog(&#10;    products: List&lt;Product&gt;,&#10;    onDismiss: () -&gt; Unit,&#10;    onAdd: (productId: Long?, name: String?, price: Double?, unit: String?, categoryName: String?) -&gt; Unit,&#10;    onPrefillFor: (Long) -&gt; Product?,&#10;    categoryNameFor: (Long) -&gt; String?&#10;) {&#10;    var name by remember { mutableStateOf(&quot;&quot;) }&#10;    var selectedId by remember { mutableStateOf&lt;Long?&gt;(null) }&#10;    var priceText by remember { mutableStateOf(&quot;&quot;) }&#10;    var unit by remember { mutableStateOf(&quot;u&quot;) }&#10;    var category by remember { mutableStateOf(&quot;&quot;) }&#10;    var busy by remember { mutableStateOf(false) }&#10;&#10;    fun prefillFrom(product: Product) {&#10;        name = product.name&#10;        priceText = if (product.price != 0.0) product.price.toString() else &quot;&quot;&#10;        unit = product.unit.ifBlank { &quot;u&quot; }&#10;        category = categoryNameFor(product.id) ?: &quot;&quot;&#10;    }&#10;&#10;    val suggestions = remember(name, products) {&#10;        val q = name.trim()&#10;        if (q.isBlank()) emptyList() else products.filter { it.name.contains(q, ignoreCase = true) }.take(8)&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                busy = true&#10;                val p = selectedId&#10;                val price = priceText.toDoubleOrNull()&#10;                onAdd(p, if (p == null) name else name.takeIf { it.isNotBlank() &amp;&amp; it != (onPrefillFor(p)?.name ?: &quot;&quot;) }, price, unit, category.ifBlank { null })&#10;                busy = false&#10;            }, enabled = !busy &amp;&amp; (selectedId != null || name.trim().isNotBlank())) { Text(&quot;Agregar&quot;) }&#10;        },&#10;        dismissButton = { TextButton(onClick = { if (!busy) onDismiss() }) { Text(&quot;Cancelar&quot;) } },&#10;        title = { Text(&quot;Agregar producto a la lista&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(&#10;                    value = name,&#10;                    onValueChange = { v -&gt;&#10;                        name = v&#10;                        val matched = products.firstOrNull { it.name.equals(v, ignoreCase = true) }&#10;                        selectedId = matched?.id&#10;                        if (matched != null) prefillFrom(matched)&#10;                    },&#10;                    label = { Text(&quot;Producto&quot;) },&#10;                    singleLine = true&#10;                )&#10;                if (suggestions.isNotEmpty()) {&#10;                    suggestions.forEach { s -&gt;&#10;                        TextButton(onClick = {&#10;                            selectedId = s.id&#10;                            prefillFrom(s)&#10;                            name = s.name&#10;                        }) { Text(s.name) }&#10;                    }&#10;                }&#10;                OutlinedTextField(&#10;                    value = priceText,&#10;                    onValueChange = { priceText = it.filter { ch -&gt; ch.isDigit() || ch == '.' } },&#10;                    label = { Text(&quot;Precio (opcional)&quot;) },&#10;                    singleLine = true,&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)&#10;                )&#10;                OutlinedTextField(&#10;                    value = unit,&#10;                    onValueChange = { unit = it },&#10;                    label = { Text(&quot;Unidad&quot;) },&#10;                    singleLine = true&#10;                )&#10;                OutlinedTextField(&#10;                    value = category,&#10;                    onValueChange = { category = it },&#10;                    label = { Text(&quot;Categoría (opcional)&quot;) },&#10;                    singleLine = true&#10;                )&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun ShareListDialog(&#10;    busy: Boolean,&#10;    message: String?,&#10;    isError: Boolean,&#10;    onDismiss: () -&gt; Unit,&#10;    onShare: (String) -&gt; Unit&#10;) {&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    val isValid = remember(email) { email.contains(&quot;@&quot;) &amp;&amp; email.contains('.') &amp;&amp; email.length &gt;= 5 }&#10;    val focusManager = LocalFocusManager.current&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            val canConfirm = !busy &amp;&amp; isValid &amp;&amp; (message == null || isError)&#10;            TextButton(onClick = {&#10;                focusManager.clearFocus()&#10;                onShare(email.trim())&#10;            }, enabled = canConfirm) {&#10;                Text(&quot;Compartir&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            val dismissLabel = if (message != null &amp;&amp; !isError) &quot;Cerrar&quot; else &quot;Cancelar&quot;&#10;            TextButton(onClick = { if (!busy) onDismiss() }) { Text(dismissLabel) }&#10;        },&#10;        title = { Text(&quot;Compartir lista&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                if (busy) {&#10;                    LinearProgressIndicator(Modifier.fillMaxWidth())&#10;                }&#10;                Text(&quot;Ingresa el email del usuario con quien deseas compartir la lista&quot;)&#10;                OutlinedTextField(&#10;                    value = email,&#10;                    onValueChange = { email = it },&#10;                    label = { Text(&quot;Email&quot;) },&#10;                    singleLine = true,&#10;                    enabled = !busy &amp;&amp; (message == null || isError),&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),&#10;                    supportingText = {&#10;                        if (!isValid &amp;&amp; email.isNotBlank() &amp;&amp; (message == null || isError)) Text(&quot;Introduce un email válido&quot;)&#10;                    }&#10;                )&#10;                if (message != null) {&#10;                    val color = if (isError) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary&#10;                    Text(message, color = color)&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;// --- New: Finalize dialog ---&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun FinalizeDialog(&#10;    listId: Long,&#10;    itemsProvider: suspend () -&gt; List&lt;ListItemDTO&gt;,&#10;    repo: AppRepository,&#10;    onDismiss: () -&gt; Unit,&#10;    onDone: () -&gt; Unit&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    var busy by remember { mutableStateOf(false) }&#10;    var includePurchasedToPantry by remember { mutableStateOf(true) }&#10;    var moveNotPurchased by remember { mutableStateOf(true) }&#10;&#10;    // Load lists to select or allow creation&#10;    val lists by repo.activeLists().collectAsState(initial = emptyList())&#10;    var creatingNew by remember { mutableStateOf(false) }&#10;    var newListName by remember { mutableStateOf(&quot;&quot;) }&#10;    var selectedListId by remember { mutableStateOf&lt;Long?&gt;(null) }&#10;&#10;    LaunchedEffect(Unit) { repo.refreshLists() }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            TextButton(&#10;                enabled = !busy,&#10;                onClick = {&#10;                    busy = true&#10;                    scope.launch {&#10;                        val items = itemsProvider()&#10;                        val purchased = items.filter { it.purchased }&#10;                        val notPurchased = items.filterNot { it.purchased }&#10;&#10;                        // 1) Add purchased to pantry&#10;                        if (includePurchasedToPantry &amp;&amp; purchased.isNotEmpty()) {&#10;                            for (it in purchased) {&#10;                                runCatching {&#10;                                    repo.addOrIncrementPantryItem(&#10;                                        productId = it.product.id ?: return@runCatching,&#10;                                        addQuantity = it.quantity.toInt(),&#10;                                        unit = it.unit&#10;                                    )&#10;                                }&#10;                            }&#10;                            // Sync pantry in background (optional)&#10;                            runCatching { repo.syncPantry() }&#10;                        }&#10;&#10;                        // 2) Move not purchased to another list&#10;                        if (moveNotPurchased &amp;&amp; notPurchased.isNotEmpty()) {&#10;                            val targetId = if (creatingNew) {&#10;                                val name = newListName.trim()&#10;                                if (name.isEmpty()) null else runCatching { repo.createList(name) }.getOrNull()&#10;                            } else selectedListId&#10;&#10;                            if (targetId != null) {&#10;                                for (it in notPurchased) {&#10;                                    runCatching {&#10;                                        repo.addItemRemote(&#10;                                            listId = targetId,&#10;                                            productId = it.product.id ?: return@runCatching,&#10;                                            quantity = it.quantity.toInt(),&#10;                                            unit = it.unit&#10;                                        )&#10;                                    }&#10;                                }&#10;                                // Refresh destination list items (optional)&#10;                                runCatching { repo.syncListItems(targetId) }&#10;                            }&#10;                        }&#10;&#10;                        // 3) Delete this list so it no longer appears in the lists screen&#10;                        runCatching { repo.deleteListRemote(listId) }&#10;                        runCatching { repo.refreshLists() }&#10;&#10;                        busy = false&#10;                        onDone()&#10;                    }&#10;                }&#10;            ) { Text(if (busy) &quot;Procesando...&quot; else &quot;Finalizar&quot;) }&#10;        },&#10;        dismissButton = { TextButton(enabled = !busy, onClick = onDismiss) { Text(&quot;Cancelar&quot;) } },&#10;        title = { Text(&quot;Finalizar lista&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;                Text(&quot;Qué deseas hacer al finalizar?&quot;)&#10;                // Purchased -&gt; Pantry&#10;                Row(verticalAlignment = androidx.compose.ui.Alignment.CenterVertically) {&#10;                    Checkbox(checked = includePurchasedToPantry, onCheckedChange = { includePurchasedToPantry = it })&#10;                    Spacer(Modifier.width(8.dp))&#10;                    Text(&quot;Agregar productos comprados a la alacena&quot;)&#10;                }&#10;                // Not purchased -&gt; another list&#10;                Row(verticalAlignment = androidx.compose.ui.Alignment.CenterVertically) {&#10;                    Checkbox(checked = moveNotPurchased, onCheckedChange = { moveNotPurchased = it })&#10;                    Spacer(Modifier.width(8.dp))&#10;                    Text(&quot;Mover productos no comprados a otra lista&quot;)&#10;                }&#10;                if (moveNotPurchased) {&#10;                    // Selector: existing vs create new&#10;                    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                        AssistChip(onClick = { creatingNew = false }, label = { Text(&quot;Seleccionar lista&quot;) }, leadingIcon = {})&#10;                        AssistChip(onClick = { creatingNew = true }, label = { Text(&quot;Crear nueva&quot;) }, leadingIcon = {})&#10;                    }&#10;                    if (creatingNew) {&#10;                        OutlinedTextField(&#10;                            value = newListName,&#10;                            onValueChange = { newListName = it },&#10;                            label = { Text(&quot;Nombre de la nueva lista&quot;) },&#10;                            singleLine = true,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                    } else {&#10;                        // Simple dropdown using a list of buttons&#10;                        Column {&#10;                            Text(&quot;Selecciona una lista destino:&quot;)&#10;                            val options = lists.filter { it.id != listId }&#10;                            if (options.isEmpty()) {&#10;                                Text(&quot;No hay listas disponibles&quot;)&#10;                            } else {&#10;                                options.forEach { l -&gt;&#10;                                    val selected = selectedListId == l.id&#10;                                    ListItem(&#10;                                        headlineContent = { Text(l.title) },&#10;                                        trailingContent = {&#10;                                            RadioButton(selected = selected, onClick = { selectedListId = l.id })&#10;                                        },&#10;                                        modifier = Modifier.fillMaxWidth()&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.tuchanguito.ui.screens.lists&#10;&#10;import android.content.Intent&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.ContentCopy&#10;import androidx.compose.material.icons.filled.Share&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.unit.dp&#10;import com.example.tuchanguito.data.AppRepository&#10;import com.example.tuchanguito.data.model.ListItem&#10;import com.example.tuchanguito.data.model.Product&#10;import com.example.tuchanguito.network.dto.ListItemDTO&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import retrofit2.HttpException&#10;import androidx.compose.ui.platform.LocalFocusManager&#10;import java.net.SocketTimeoutException&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ListDetailScreen(listId: Long, onClose: () -&gt; Unit = {}) {&#10;    val context = LocalContext.current&#10;    val repo = remember { AppRepository.get(context) }&#10;    val list by repo.listById(listId).collectAsState(initial = null)&#10;    val listItems by repo.itemsForList(listId).collectAsState(initial = emptyList())&#10;    val products by repo.products().collectAsState(initial = emptyList())&#10;    val categories by repo.categories().collectAsState(initial = emptyList())&#10;    val scope = rememberCoroutineScope()&#10;    val snack = remember { SnackbarHostState() }&#10;&#10;    // Remote-backed fallback for items&#10;    var remoteItems by remember { mutableStateOf&lt;List&lt;ListItemDTO&gt;&gt;(emptyList()) }&#10;&#10;    // Initial sync from backend so detail shows server data&#10;    LaunchedEffect(listId) {&#10;        repo.loadListIntoLocal(listId)&#10;        runCatching { repo.syncCatalog() }&#10;        runCatching { repo.syncListItems(listId) }&#10;        // Keep a remote snapshot once for fallback rendering&#10;        remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;    }&#10;&#10;    // Helper maps&#10;    val productById = remember(products) { products.associateBy { it.id } }&#10;    val remoteByProductId = remember(remoteItems) { remoteItems.associateBy { it.product.id ?: -1L } }&#10;    val categoryById = remember(categories) { categories.associateBy { it.id } }&#10;&#10;    // Choose source for UI&#10;    val uiProducts: List&lt;Long&gt; = remember(listItems, remoteItems) {&#10;        if (listItems.isNotEmpty()) listItems.map { it.productId } else remoteItems.map { it.product.id ?: -1L }&#10;    }&#10;&#10;    val total = remember(uiProducts, products, listItems, remoteItems) {&#10;        uiProducts.sumOf { pid -&gt;&#10;            val qty = listItems.firstOrNull { it.productId == pid }?.quantity&#10;                ?: remoteByProductId[pid]?.quantity?.toInt()&#10;                ?: 0&#10;            val price = productById[pid]?.price ?: 0.0&#10;            (price * qty).toInt()&#10;        }&#10;    }&#10;&#10;    var showAdd by remember { mutableStateOf(false) }&#10;    var showFinalize by remember { mutableStateOf(false) }&#10;    var showShare by remember { mutableStateOf(false) }&#10;    var shareBusy by remember { mutableStateOf(false) }&#10;    var shareMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var shareIsError by remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(title = { Text(list?.title ?: &quot;Lista&quot;) }, actions = {&#10;                IconButton(onClick = {&#10;                    // Share list via app share sheet (copy text)&#10;                    val body = buildString {&#10;                        appendLine(list?.title ?: &quot;Lista&quot;)&#10;                        appendLine()&#10;                        listItems.forEach { li -&gt;&#10;                            val prod = products.firstOrNull { it.id == li.productId }&#10;                            appendLine(&quot;- ${prod?.name ?: &quot;Producto&quot;} x${li.quantity}&quot;)&#10;                        }&#10;                        appendLine()&#10;                        append(&quot;Total: \$${total}&quot;)&#10;                    }&#10;                    val send = Intent(Intent.ACTION_SEND).apply { type = &quot;text/plain&quot;; putExtra(Intent.EXTRA_TEXT, body) }&#10;                    context.startActivity(Intent.createChooser(send, &quot;Compartir lista&quot;))&#10;                }) { Icon(Icons.Default.ContentCopy, contentDescription = &quot;Copiar contenido de la lista&quot;) }&#10;                IconButton(onClick = {&#10;                    // Reset message state each time dialog opens&#10;                    shareMessage = null&#10;                    shareIsError = false&#10;                    showShare = true&#10;                }) {&#10;                    Icon(Icons.Default.Share, contentDescription = &quot;Compartir lista con usuario&quot;)&#10;                }&#10;            })&#10;        },&#10;        snackbarHost = { SnackbarHost(hostState = snack) },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = { showAdd = true }) { Icon(Icons.Default.Add, contentDescription = null) }&#10;        }&#10;    ) { padding -&gt;&#10;        Column(Modifier.fillMaxSize().padding(padding)) {&#10;            // Group by local categoryId, falling back to remote product.category.id&#10;            val grouped = remember(uiProducts, products, remoteItems) {&#10;                uiProducts.groupBy { pid -&gt;&#10;                    productById[pid]?.categoryId ?: remoteByProductId[pid]?.product?.category?.id&#10;                }&#10;            }&#10;            LazyColumn(Modifier.weight(1f)) {&#10;                grouped.forEach { (catId, pids) -&gt;&#10;                    val catName = categories.firstOrNull { it.id == catId }?.name&#10;                        ?: pids.firstOrNull()?.let { firstPid -&gt;&#10;                            remoteByProductId[firstPid]?.product?.category?.name&#10;                        }&#10;                        ?: &quot;Sin categoría&quot;&#10;                    item(key = &quot;header-$catId&quot;) { Text(catName, style = MaterialTheme.typography.titleMedium, modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)) }&#10;                    items(pids, key = { it }) { pid -&gt;&#10;                        val product = productById[pid]&#10;                        val local = listItems.firstOrNull { it.productId == pid }&#10;                        val remote = remoteByProductId[pid]&#10;                        val qty = local?.quantity ?: remote?.quantity?.toInt() ?: 0&#10;                        val itemForRow = local ?: ListItem(&#10;                            id = remote?.id ?: 0L,&#10;                            listId = listId,&#10;                            productId = pid,&#10;                            quantity = qty,&#10;                            acquired = remote?.purchased ?: false&#10;                        )&#10;                        val unit = product?.unit?.ifBlank { remote?.unit ?: &quot;u&quot; } ?: (remote?.unit ?: &quot;u&quot;)&#10;                        ListRow(&#10;                            productName = product?.name ?: remote?.product?.name ?: &quot;Producto&quot;,&#10;                            price = product?.price ?: 0.0,&#10;                            unit = unit,&#10;                            item = itemForRow,&#10;                            onInc = {&#10;                                val existingId = local?.id ?: remote?.id&#10;                                scope.launch {&#10;                                    try {&#10;                                        if (existingId != null &amp;&amp; existingId &gt; 0) {&#10;                                            repo.updateItemQuantityRemote(listId, existingId, pid, qty + 1, unit)&#10;                                        } else {&#10;                                            repo.addItemRemote(listId, pid, (qty + 1).coerceAtLeast(1), unit)&#10;                                        }&#10;                                        // Fetch a single fresh snapshot for remote fallback&#10;                                        remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                                    } catch (t: Throwable) {&#10;                                        snack.showSnackbar(t.message ?: &quot;No se pudo actualizar la cantidad&quot;)&#10;                                    }&#10;                                }&#10;                            },&#10;                            onDec = {&#10;                                if (qty &gt; 1) {&#10;                                    val existingId = local?.id ?: remote?.id&#10;                                    if (existingId != null &amp;&amp; existingId &gt; 0) {&#10;                                        scope.launch {&#10;                                            try {&#10;                                                repo.updateItemQuantityRemote(listId, existingId, pid, qty - 1, unit)&#10;                                                remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                                            } catch (t: Throwable) {&#10;                                                snack.showSnackbar(t.message ?: &quot;No se pudo actualizar la cantidad&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            },&#10;                            onDelete = {&#10;                                val existingId = local?.id ?: remote?.id&#10;                                if (existingId != null &amp;&amp; existingId &gt; 0) {&#10;                                    scope.launch {&#10;                                        try {&#10;                                            if (local != null) repo.deleteItemRemote(listId, existingId, local) else runCatching { repo.deleteItemRemote(listId, existingId, ListItem(id = existingId, listId = listId, productId = pid, quantity = qty)) }&#10;                                            // Single refresh for fallback&#10;                                            remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                                        } catch (t: Throwable) {&#10;                                            snack.showSnackbar(t.message ?: &quot;No se pudo eliminar el producto de la lista&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            },&#10;                            onToggleAcquired = {&#10;                                val existingId = local?.id ?: remote?.id&#10;                                if (existingId != null &amp;&amp; existingId &gt; 0) {&#10;                                    val newPurchased = !(local?.acquired ?: (remote?.purchased ?: false))&#10;                                    scope.launch {&#10;                                        try {&#10;                                            repo.toggleItemPurchasedRemote(listId, existingId, newPurchased)&#10;                                            remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                                        } catch (t: Throwable) {&#10;                                            snack.showSnackbar(t.message ?: &quot;No se pudo cambiar el estado&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            Text(&quot;Costo total: \$${total}&quot;, style = MaterialTheme.typography.headlineSmall, modifier = Modifier.padding(16.dp))&#10;            // Reserve space at end for the floating action button (approx 72-88dp)&#10;            Row(&#10;                Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, end = 88.dp, bottom = 16.dp, top = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                OutlinedButton(&#10;                    onClick = onClose,&#10;                    modifier = Modifier&#10;                        .weight(0.45f)&#10;                        .heightIn(min = 36.dp)&#10;                ) { Text(&quot;Cerrar lista&quot;) }&#10;                Button(&#10;                    onClick = { showFinalize = true },&#10;                    modifier = Modifier&#10;                        .weight(0.45f)&#10;                        .heightIn(min = 36.dp)&#10;                ) { Text(&quot;Finalizar&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAdd) {&#10;        AddItemDialog(&#10;            products = products,&#10;            onDismiss = { showAdd = false },&#10;            onAdd = { productId, name, price, unit, categoryName -&gt;&#10;                scope.launch {&#10;                    try {&#10;                        val chosenProductId: Long = productId ?: run {&#10;                            val catId = categoryName?.let { if (it.isNotBlank()) repo.createOrFindCategoryByName(it) else null }&#10;                            repo.createProductRemote(name!!.trim(), price ?: 0.0, unit ?: &quot;u&quot;, catId)&#10;                        }&#10;                        if (productId != null) {&#10;                            val existing = products.firstOrNull { it.id == productId }&#10;                            val existingCategoryName = existing?.categoryId?.let { cid -&gt; categoryById[cid]?.name }&#10;                            val changedName = !name.isNullOrBlank()&#10;                            val changedPrice = price != null&#10;                            val changedUnit = !unit.isNullOrBlank() &amp;&amp; unit != existing?.unit&#10;                            val changedCategory = !categoryName.isNullOrBlank() &amp;&amp; !categoryName.equals(existingCategoryName, ignoreCase = true)&#10;                            if (changedName || changedPrice || changedUnit || changedCategory) {&#10;                                val catId = if (changedCategory) repo.createOrFindCategoryByName(categoryName) else existing?.categoryId&#10;                                repo.updateProductRemote(&#10;                                    id = productId,&#10;                                    name = name ?: existing?.name ?: &quot;&quot;,&#10;                                    price = price ?: existing?.price ?: 0.0,&#10;                                    unit = unit ?: existing?.unit ?: &quot;u&quot;,&#10;                                    categoryId = catId&#10;                                )&#10;                            }&#10;                        }&#10;                        val fallbackUnit = products.firstOrNull { it.id == chosenProductId }?.unit?.ifBlank { &quot;u&quot; } ?: &quot;u&quot;&#10;                        val safeUnitForItem = (unit?.takeIf { it.isNotBlank() } ?: fallbackUnit)&#10;                        repo.addItemRemote(listId, chosenProductId, 1, safeUnitForItem)&#10;                        // Single remote refresh for fallback&#10;                        remoteItems = runCatching { repo.fetchListItemsRemote(listId) }.getOrDefault(emptyList())&#10;                        showAdd = false&#10;                    } catch (t: Throwable) {&#10;                        snack.showSnackbar(t.message ?: &quot;No se pudo agregar el producto a la lista&quot;)&#10;                    }&#10;                }&#10;            },&#10;            onPrefillFor = { pid -&gt; products.firstOrNull { it.id == pid } },&#10;            categoryNameFor = { pid -&gt;&#10;                val prod = products.firstOrNull { it.id == pid }&#10;                prod?.categoryId?.let { cid -&gt; categoryById[cid]?.name }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showShare) {&#10;        ShareListDialog(&#10;            busy = shareBusy,&#10;            message = shareMessage,&#10;            isError = shareIsError,&#10;            onDismiss = {&#10;                if (!shareBusy) {&#10;                    showShare = false&#10;                    shareMessage = null&#10;                    shareIsError = false&#10;                }&#10;            },&#10;            onShare = { email -&gt;&#10;                if (shareBusy) return@ShareListDialog&#10;                shareBusy = true&#10;                shareMessage = null&#10;                shareIsError = false&#10;                scope.launch {&#10;                    try {&#10;                        repo.shareListRemote(listId, email)&#10;                        // Success: show concise success message&#10;                        shareMessage = &quot;La lista ha sido compartida&quot;&#10;                        shareIsError = false&#10;                    } catch (t: Throwable) {&#10;                        // If it's a network timeout, optimistically report success because the server may have processed it&#10;                        val isTimeout = t is SocketTimeoutException || (t.message?.contains(&quot;timeout&quot;, ignoreCase = true) == true)&#10;                        if (isTimeout) {&#10;                            shareMessage = &quot;La lista ha sido compartida&quot;&#10;                            shareIsError = false&#10;                        } else {&#10;                            val code = (t as? HttpException)?.code()&#10;                            val msg = when (code) {&#10;                                404 -&gt; &quot;No encontramos un usuario registrado con ese email&quot;&#10;                                409 -&gt; &quot;Ya compartiste esta lista con ese email&quot;&#10;                                400 -&gt; &quot;No se pudo compartir la lista. Verifica el email.&quot;&#10;                                401, 403 -&gt; &quot;No estás autorizado para realizar esta acción&quot;&#10;                                else -&gt; t.message ?: &quot;No se pudo compartir la lista&quot;&#10;                            }&#10;                            shareMessage = msg&#10;                            shareIsError = true&#10;                        }&#10;                    } finally {&#10;                        shareBusy = false&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // --- Finalize dialog state and UI ---&#10;    var finalizing by remember { mutableStateOf(false) }&#10;&#10;    // Replace Finalizar button onClick to open dialog&#10;    LaunchedEffect(Unit) {&#10;        // no-op placeholder to satisfy tool insertion constraints&#10;    }&#10;&#10;    if (showFinalize) {&#10;        FinalizeDialog(&#10;            listId = listId,&#10;            itemsProvider = {&#10;                // Always fetch a fresh snapshot from server to ensure accurate purchased flags&#10;                try { repo.fetchListItemsRemote(listId) } catch (_: Throwable) { remoteItems }&#10;            },&#10;            repo = repo,&#10;            onDismiss = { if (!finalizing) showFinalize = false },&#10;            onDone = { showFinalize = false; onClose() }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ListRow(&#10;    productName: String,&#10;    price: Double,&#10;    unit: String,&#10;    item: ListItem,&#10;    onInc: () -&gt; Unit,&#10;    onDec: () -&gt; Unit,&#10;    onDelete: () -&gt; Unit,&#10;    onToggleAcquired: () -&gt; Unit&#10;) {&#10;    ListItem(&#10;        leadingContent = {&#10;            Checkbox(checked = item.acquired, onCheckedChange = { onToggleAcquired() })&#10;        },&#10;        headlineContent = { Text(productName) },&#10;        supportingContent = { Text(&quot;\$${price} · ${unit} x ${item.quantity}&quot;) },&#10;        trailingContent = {&#10;            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                TextButton(onClick = onDec) { Text(&quot;-&quot;) }&#10;                Text(&quot;${item.quantity}&quot;)&#10;                TextButton(onClick = onInc) { Text(&quot;+&quot;) }&#10;                IconButton(onClick = onDelete) { Icon(Icons.Default.Delete, contentDescription = null) }&#10;            }&#10;        },&#10;        modifier = Modifier.fillMaxWidth()&#10;    )&#10;    HorizontalDivider()&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun AddItemDialog(&#10;    products: List&lt;Product&gt;,&#10;    onDismiss: () -&gt; Unit,&#10;    onAdd: (productId: Long?, name: String?, price: Double?, unit: String?, categoryName: String?) -&gt; Unit,&#10;    onPrefillFor: (Long) -&gt; Product?,&#10;    categoryNameFor: (Long) -&gt; String?&#10;) {&#10;    var name by remember { mutableStateOf(&quot;&quot;) }&#10;    var selectedId by remember { mutableStateOf&lt;Long?&gt;(null) }&#10;    var priceText by remember { mutableStateOf(&quot;&quot;) }&#10;    var unit by remember { mutableStateOf(&quot;u&quot;) }&#10;    var category by remember { mutableStateOf(&quot;&quot;) }&#10;    var busy by remember { mutableStateOf(false) }&#10;&#10;    fun prefillFrom(product: Product) {&#10;        name = product.name&#10;        priceText = if (product.price != 0.0) product.price.toString() else &quot;&quot;&#10;        unit = product.unit.ifBlank { &quot;u&quot; }&#10;        category = categoryNameFor(product.id) ?: &quot;&quot;&#10;    }&#10;&#10;    val suggestions = remember(name, products) {&#10;        val q = name.trim()&#10;        if (q.isBlank()) emptyList() else products.filter { it.name.contains(q, ignoreCase = true) }.take(8)&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                busy = true&#10;                val p = selectedId&#10;                val price = priceText.toDoubleOrNull()&#10;                onAdd(p, if (p == null) name else name.takeIf { it.isNotBlank() &amp;&amp; it != (onPrefillFor(p)?.name ?: &quot;&quot;) }, price, unit, category.ifBlank { null })&#10;                busy = false&#10;            }, enabled = !busy &amp;&amp; (selectedId != null || name.trim().isNotBlank())) { Text(&quot;Agregar&quot;) }&#10;        },&#10;        dismissButton = { TextButton(onClick = { if (!busy) onDismiss() }) { Text(&quot;Cancelar&quot;) } },&#10;        title = { Text(&quot;Agregar producto a la lista&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(&#10;                    value = name,&#10;                    onValueChange = { v -&gt;&#10;                        name = v&#10;                        val matched = products.firstOrNull { it.name.equals(v, ignoreCase = true) }&#10;                        selectedId = matched?.id&#10;                        if (matched != null) prefillFrom(matched)&#10;                    },&#10;                    label = { Text(&quot;Producto&quot;) },&#10;                    singleLine = true&#10;                )&#10;                if (suggestions.isNotEmpty()) {&#10;                    suggestions.forEach { s -&gt;&#10;                        TextButton(onClick = {&#10;                            selectedId = s.id&#10;                            prefillFrom(s)&#10;                            name = s.name&#10;                        }) { Text(s.name) }&#10;                    }&#10;                }&#10;                OutlinedTextField(&#10;                    value = priceText,&#10;                    onValueChange = { priceText = it.filter { ch -&gt; ch.isDigit() || ch == '.' } },&#10;                    label = { Text(&quot;Precio (opcional)&quot;) },&#10;                    singleLine = true,&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)&#10;                )&#10;                OutlinedTextField(&#10;                    value = unit,&#10;                    onValueChange = { unit = it },&#10;                    label = { Text(&quot;Unidad&quot;) },&#10;                    singleLine = true&#10;                )&#10;                OutlinedTextField(&#10;                    value = category,&#10;                    onValueChange = { category = it },&#10;                    label = { Text(&quot;Categoría (opcional)&quot;) },&#10;                    singleLine = true&#10;                )&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun ShareListDialog(&#10;    busy: Boolean,&#10;    message: String?,&#10;    isError: Boolean,&#10;    onDismiss: () -&gt; Unit,&#10;    onShare: (String) -&gt; Unit&#10;) {&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    val isValid = remember(email) { email.contains(&quot;@&quot;) &amp;&amp; email.contains('.') &amp;&amp; email.length &gt;= 5 }&#10;    val focusManager = LocalFocusManager.current&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            val canConfirm = !busy &amp;&amp; isValid &amp;&amp; (message == null || isError)&#10;            TextButton(onClick = {&#10;                focusManager.clearFocus()&#10;                onShare(email.trim())&#10;            }, enabled = canConfirm) {&#10;                Text(&quot;Compartir&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            val dismissLabel = if (message != null &amp;&amp; !isError) &quot;Cerrar&quot; else &quot;Cancelar&quot;&#10;            TextButton(onClick = { if (!busy) onDismiss() }) { Text(dismissLabel) }&#10;        },&#10;        title = { Text(&quot;Compartir lista&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                if (busy) {&#10;                    LinearProgressIndicator(Modifier.fillMaxWidth())&#10;                }&#10;                Text(&quot;Ingresa el email del usuario con quien deseas compartir la lista&quot;)&#10;                OutlinedTextField(&#10;                    value = email,&#10;                    onValueChange = { email = it },&#10;                    label = { Text(&quot;Email&quot;) },&#10;                    singleLine = true,&#10;                    enabled = !busy &amp;&amp; (message == null || isError),&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),&#10;                    supportingText = {&#10;                        if (!isValid &amp;&amp; email.isNotBlank() &amp;&amp; (message == null || isError)) Text(&quot;Introduce un email válido&quot;)&#10;                    }&#10;                )&#10;                if (message != null) {&#10;                    val color = if (isError) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary&#10;                    Text(message, color = color)&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;// --- New: Finalize dialog ---&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun FinalizeDialog(&#10;    listId: Long,&#10;    itemsProvider: suspend () -&gt; List&lt;ListItemDTO&gt;,&#10;    repo: AppRepository,&#10;    onDismiss: () -&gt; Unit,&#10;    onDone: () -&gt; Unit&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    var busy by remember { mutableStateOf(false) }&#10;    var includePurchasedToPantry by remember { mutableStateOf(true) }&#10;    var moveNotPurchased by remember { mutableStateOf(true) }&#10;&#10;    // Load lists to select or allow creation&#10;    val lists by repo.activeLists().collectAsState(initial = emptyList())&#10;    var creatingNew by remember { mutableStateOf(false) }&#10;    var newListName by remember { mutableStateOf(&quot;&quot;) }&#10;    var selectedListId by remember { mutableStateOf&lt;Long?&gt;(null) }&#10;&#10;    LaunchedEffect(Unit) { repo.refreshLists() }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            TextButton(&#10;                enabled = !busy,&#10;                onClick = {&#10;                    busy = true&#10;                    scope.launch {&#10;                        // Always fetch a fresh snapshot before acting&#10;                        runCatching { repo.syncListItems(listId) }&#10;                        val items = runCatching { itemsProvider() }.getOrElse { emptyList() }&#10;                        val purchased = items.filter { it.purchased }&#10;                        val notPurchased = items.filterNot { it.purchased }&#10;&#10;                        // 1) Prefer server endpoint to move purchased to pantry (owner-only)&#10;                        var movedByServer = false&#10;                        if (includePurchasedToPantry &amp;&amp; purchased.isNotEmpty()) {&#10;                            movedByServer = runCatching {&#10;                                repo.movePurchasedToPantry(listId)&#10;                                true&#10;                            }.getOrElse { false }&#10;&#10;                            if (!movedByServer) {&#10;                                // Fallback: client-side add/increment per product&#10;                                for (it in purchased) {&#10;                                    runCatching {&#10;                                        val pid: Long? = it.product.id ?: run {&#10;                                            val candidates = runCatching { repo.searchProductsDTO(name = it.product.name, categoryId = it.product.category?.id) }.getOrDefault(emptyList())&#10;                                            candidates.firstOrNull { c -&gt; c.name.equals(it.product.name, ignoreCase = true) }?.id&#10;                                        }&#10;                                        if (pid != null) {&#10;                                            val unit = it.unit.ifBlank { &quot;u&quot; }&#10;                                            repo.addOrIncrementPantryItem(&#10;                                                productId = pid,&#10;                                                addQuantity = it.quantity.toInt(),&#10;                                                unit = unit&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                                // Try a light sync; if server GET fails, local upserts still keep UI consistent&#10;                                runCatching { repo.syncPantry() }&#10;                            }&#10;                        }&#10;&#10;                        // 2) Move not purchased to another list&#10;                        if (moveNotPurchased &amp;&amp; notPurchased.isNotEmpty()) {&#10;                            val targetId = if (creatingNew) {&#10;                                val name = newListName.trim()&#10;                                if (name.isEmpty()) null else runCatching { repo.createList(name) }.getOrNull()&#10;                            } else selectedListId&#10;&#10;                            if (targetId != null) {&#10;                                for (it in notPurchased) {&#10;                                    runCatching {&#10;                                        val pid = it.product.id ?: run {&#10;                                            val candidates = runCatching { repo.searchProductsDTO(name = it.product.name, categoryId = it.product.category?.id) }.getOrDefault(emptyList())&#10;                                            candidates.firstOrNull { c -&gt; c.name.equals(it.product.name, ignoreCase = true) }?.id&#10;                                        }&#10;                                        if (pid != null) {&#10;                                            repo.addItemRemote(&#10;                                                listId = targetId,&#10;                                                productId = pid,&#10;                                                quantity = it.quantity.toInt(),&#10;                                                unit = it.unit.ifBlank { &quot;u&quot; }&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                                // Optional refresh for destination&#10;                                runCatching { repo.syncListItems(targetId) }&#10;                            }&#10;                        }&#10;&#10;                        // 3) Delete this list so it no longer appears in the lists screen&#10;                        runCatching { repo.deleteListRemote(listId) }&#10;                        runCatching { repo.refreshLists() }&#10;&#10;                        busy = false&#10;                        onDone()&#10;                    }&#10;                }&#10;            ) { Text(if (busy) &quot;Procesando...&quot; else &quot;Finalizar&quot;) }&#10;        },&#10;        dismissButton = { TextButton(enabled = !busy, onClick = onDismiss) { Text(&quot;Cancelar&quot;) } },&#10;        title = { Text(&quot;Finalizar lista&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;                Text(&quot;Qué deseas hacer al finalizar?&quot;)&#10;                // Purchased -&gt; Pantry&#10;                Row(verticalAlignment = androidx.compose.ui.Alignment.CenterVertically) {&#10;                    Checkbox(checked = includePurchasedToPantry, onCheckedChange = { includePurchasedToPantry = it })&#10;                    Spacer(Modifier.width(8.dp))&#10;                    Text(&quot;Agregar productos comprados a la alacena&quot;)&#10;                }&#10;                // Not purchased -&gt; another list&#10;                Row(verticalAlignment = androidx.compose.ui.Alignment.CenterVertically) {&#10;                    Checkbox(checked = moveNotPurchased, onCheckedChange = { moveNotPurchased = it })&#10;                    Spacer(Modifier.width(8.dp))&#10;                    Text(&quot;Mover productos no comprados a otra lista&quot;)&#10;                }&#10;                if (moveNotPurchased) {&#10;                    // Selector: existing vs create new&#10;                    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                        AssistChip(onClick = { creatingNew = false }, label = { Text(&quot;Seleccionar lista&quot;) }, leadingIcon = {})&#10;                        AssistChip(onClick = { creatingNew = true }, label = { Text(&quot;Crear nueva&quot;) }, leadingIcon = {})&#10;                    }&#10;                    if (creatingNew) {&#10;                        OutlinedTextField(&#10;                            value = newListName,&#10;                            onValueChange = { newListName = it },&#10;                            label = { Text(&quot;Nombre de la nueva lista&quot;) },&#10;                            singleLine = true,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                    } else {&#10;                        // Simple dropdown using a list of buttons&#10;                        Column {&#10;                            Text(&quot;Selecciona una lista destino:&quot;)&#10;                            val options = lists.filter { it.id != listId }&#10;                            if (options.isEmpty()) {&#10;                                Text(&quot;No hay listas disponibles&quot;)&#10;                            } else {&#10;                                options.forEach { l -&gt;&#10;                                    val selected = selectedListId == l.id&#10;                                    ListItem(&#10;                                        headlineContent = { Text(l.title) },&#10;                                        trailingContent = {&#10;                                            RadioButton(selected = selected, onClick = { selectedListId = l.id })&#10;                                        },&#10;                                        modifier = Modifier.fillMaxWidth()&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/screens/pantry/PantryScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/tuchanguito/ui/screens/pantry/PantryScreen.kt" />
              <option name="originalContent" value="package com.example.tuchanguito.ui.screens.pantry&#10;&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.dp&#10;import com.example.tuchanguito.data.AppRepository&#10;import com.example.tuchanguito.data.model.Category&#10;import com.example.tuchanguito.data.model.Product&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PantryScreen() {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val repo = remember { AppRepository.get(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val pantryItems by repo.pantry().collectAsState(initial = emptyList())&#10;    val products by repo.products().collectAsState(initial = emptyList())&#10;    val categories by repo.categories().collectAsState(initial = emptyList())&#10;&#10;    val snack = remember { SnackbarHostState() }&#10;&#10;    var query by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var selectedCategoryId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var showAdd by rememberSaveable { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        runCatching { repo.syncCatalog() }&#10;        // Load full pantry inventory once; filters are applied locally in UI&#10;        runCatching { repo.syncPantry() }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = { TopAppBar(title = { Text(&quot;Alacena&quot;) }) },&#10;        snackbarHost = { SnackbarHost(snack) },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = { showAdd = true }) { Icon(Icons.Default.Add, contentDescription = null) }&#10;        }&#10;    ) { padding -&gt;&#10;        Column(Modifier.fillMaxSize().padding(padding).padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;            OutlinedTextField(&#10;                value = query,&#10;                onValueChange = { query = it },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                label = { Text(&quot;Buscar&quot;) },&#10;                singleLine = true&#10;            )&#10;            LazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {&#10;                item {&#10;                    FilterChip(selected = selectedCategoryId == null, onClick = {&#10;                        selectedCategoryId = null&#10;                    }, label = { Text(&quot;Todas&quot;) })&#10;                }&#10;                items(categories.size) { i -&gt;&#10;                    val c = categories[i]&#10;                    FilterChip(selected = selectedCategoryId == c.id, onClick = {&#10;                        selectedCategoryId = c.id&#10;                    }, label = { Text(c.name) })&#10;                }&#10;            }&#10;&#10;            Divider()&#10;&#10;            val productById = remember(products) { products.associateBy { it.id } }&#10;            // Apply filters locally using product name/category&#10;            val filteredPantry = remember(pantryItems, products, query, selectedCategoryId) {&#10;                pantryItems.filter { pi -&gt;&#10;                    val p = productById[pi.productId]&#10;                    val matchesQuery = query.isBlank() || (p?.name?.contains(query, ignoreCase = true) == true)&#10;                    val matchesCategory = selectedCategoryId == null || p?.categoryId == selectedCategoryId&#10;                    matchesQuery &amp;&amp; matchesCategory&#10;                }&#10;            }&#10;&#10;            LazyColumn(Modifier.fillMaxWidth().weight(1f), contentPadding = PaddingValues(bottom = 88.dp)) {&#10;                if (filteredPantry.isEmpty()) {&#10;                    item { Text(&quot;Sin productos en la alacena&quot;, style = MaterialTheme.typography.bodyMedium) }&#10;                } else {&#10;                    items(filteredPantry.size) { idx -&gt;&#10;                        val pi = filteredPantry[idx]&#10;                        val p = productById[pi.productId]&#10;                        PantryRow(&#10;                            name = p?.name ?: &quot;Producto&quot;,&#10;                            unit = p?.unit?.ifBlank { &quot;u&quot; } ?: &quot;u&quot;,&#10;                            quantity = pi.quantity,&#10;                            onInc = { scope.launch { repo.updatePantryItem(pi.id, pi.quantity + 1); runCatching { repo.syncPantry() } } },&#10;                            onDec = { if (pi.quantity &gt; 1) scope.launch { repo.updatePantryItem(pi.id, pi.quantity - 1); runCatching { repo.syncPantry() } } },&#10;                            onDelete = { scope.launch { repo.deletePantryItem(pi.id) } }&#10;                        )&#10;                        Divider()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAdd) {&#10;        val categoryById: Map&lt;Long, Category&gt; = remember(categories) { categories.associateBy { it.id } }&#10;        AddPantryItemDialog(&#10;            products = products,&#10;            categories = categories.map { it.name },&#10;            categoryNameFor = { pid -&gt;&#10;                val prod = products.firstOrNull { it.id == pid }&#10;                prod?.categoryId?.let { cid -&gt; categoryById[cid]?.name }&#10;            },&#10;            onDismiss = { showAdd = false },&#10;            onAdd = { productId, name, price, unit, categoryName -&gt;&#10;                scope.launch {&#10;                    try {&#10;                        val finalProductId = if (productId != null) {&#10;                            val existing = products.firstOrNull { it.id == productId }&#10;                            if (!name.isNullOrBlank() || price != null || !unit.isNullOrBlank() || !categoryName.isNullOrBlank()) {&#10;                                val catId = categoryName?.takeIf { it.isNotBlank() }?.let { repo.createOrFindCategoryByName(it) } ?: existing?.categoryId&#10;                                repo.updateProductRemote(productId, name ?: existing?.name ?: &quot;&quot;, price ?: existing?.price ?: 0.0, unit ?: existing?.unit ?: &quot;u&quot;, catId)&#10;                            }&#10;                            productId&#10;                        } else {&#10;                            val catId = categoryName?.takeIf { it.isNotBlank() }?.let { repo.createOrFindCategoryByName(it) }&#10;                            repo.createProductRemote(name!!.trim(), price ?: 0.0, unit ?: &quot;u&quot;, catId)&#10;                        }&#10;                        // Use addOrIncrement to avoid 409 and crashes if already exists&#10;                        repo.addOrIncrementPantryItem(finalProductId, addQuantity = 1, unit = unit ?: &quot;u&quot;)&#10;                        runCatching { repo.syncPantry() }&#10;                        showAdd = false&#10;                    } catch (t: Throwable) {&#10;                        snack.showSnackbar(t.message ?: &quot;No se pudo agregar el producto a la alacena&quot;)&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun AddPantryItemDialog(&#10;    products: List&lt;Product&gt;,&#10;    categories: List&lt;String&gt;,&#10;    categoryNameFor: (Long) -&gt; String?,&#10;    onDismiss: () -&gt; Unit,&#10;    onAdd: (productId: Long?, name: String?, price: Double?, unit: String?, categoryName: String?) -&gt; Unit&#10;) {&#10;    var name by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var selectedId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var priceText by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var unit by rememberSaveable { mutableStateOf(&quot;u&quot;) }&#10;    var category by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var busy by remember { mutableStateOf(false) }&#10;&#10;    fun prefill(product: Product) {&#10;        name = product.name&#10;        priceText = if (product.price != 0.0) product.price.toString() else &quot;&quot;&#10;        unit = product.unit.ifBlank { &quot;u&quot; }&#10;        category = categoryNameFor(product.id) ?: &quot;&quot;&#10;    }&#10;&#10;    val suggestions = remember(name, products) {&#10;        val q = name.trim()&#10;        if (q.isBlank()) emptyList() else products.filter { it.name.contains(q, ignoreCase = true) }.take(8)&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                busy = true&#10;                val price = priceText.toDoubleOrNull()&#10;                onAdd(selectedId, if (selectedId == null) name else name.takeIf { it.isNotBlank() }, price, unit, category.ifBlank { null })&#10;                busy = false&#10;            }, enabled = !busy &amp;&amp; (selectedId != null || name.isNotBlank())) { Text(&quot;Agregar&quot;) }&#10;        },&#10;        dismissButton = { TextButton(onClick = { if (!busy) onDismiss() }) { Text(&quot;Cancelar&quot;) } },&#10;        title = { Text(&quot;Agregar a la alacena&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(&#10;                    value = name,&#10;                    onValueChange = { v -&gt;&#10;                        name = v&#10;                        val match = products.firstOrNull { it.name.equals(v, ignoreCase = true) }&#10;                        selectedId = match?.id&#10;                        if (match != null) prefill(match)&#10;                    },&#10;                    label = { Text(&quot;Producto&quot;) },&#10;                    singleLine = true&#10;                )&#10;                if (suggestions.isNotEmpty()) {&#10;                    suggestions.forEach { s -&gt;&#10;                        TextButton(onClick = { selectedId = s.id; prefill(s); name = s.name }) { Text(s.name) }&#10;                    }&#10;                }&#10;                OutlinedTextField(value = priceText, onValueChange = { priceText = it.filter { ch -&gt; ch.isDigit() || ch == '.' } }, label = { Text(&quot;Precio (opcional)&quot;) }, singleLine = true)&#10;                OutlinedTextField(value = unit, onValueChange = { unit = it }, label = { Text(&quot;Unidad&quot;) }, singleLine = true)&#10;                OutlinedTextField(value = category, onValueChange = { category = it }, label = { Text(&quot;Categoría (opcional)&quot;) }, singleLine = true)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun PantryRow(&#10;    name: String,&#10;    unit: String,&#10;    quantity: Int,&#10;    onInc: () -&gt; Unit,&#10;    onDec: () -&gt; Unit,&#10;    onDelete: () -&gt; Unit&#10;) {&#10;    ListItem(&#10;        headlineContent = { Text(name) },&#10;        supportingContent = { Text(&quot;$unit x $quantity&quot;) },&#10;        trailingContent = {&#10;            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                TextButton(onClick = onDec) { Text(&quot;-&quot;) }&#10;                Text(quantity.toString())&#10;                TextButton(onClick = onInc) { Text(&quot;+&quot;) }&#10;                IconButton(onClick = onDelete) { Icon(Icons.Default.Delete, contentDescription = null) }&#10;            }&#10;        }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.tuchanguito.ui.screens.pantry&#10;&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.dp&#10;import com.example.tuchanguito.data.AppRepository&#10;import com.example.tuchanguito.data.model.Category&#10;import com.example.tuchanguito.data.model.Product&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PantryScreen() {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val repo = remember { AppRepository.get(context) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val pantryItems by repo.pantry().collectAsState(initial = emptyList())&#10;    val products by repo.products().collectAsState(initial = emptyList())&#10;    val categories by repo.categories().collectAsState(initial = emptyList())&#10;&#10;    val snack = remember { SnackbarHostState() }&#10;&#10;    var query by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var selectedCategoryId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var showAdd by rememberSaveable { mutableStateOf(false) }&#10;&#10;    var remoteCategories by remember { mutableStateOf&lt;List&lt;com.example.tuchanguito.network.dto.CategoryDTO&gt;&gt;(emptyList()) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        runCatching { repo.syncCatalog() }&#10;        // Backend-driven initial pantry load (no filters)&#10;        runCatching { repo.syncPantry() }&#10;        // Load pantry categories from backend so only those with items appear&#10;        remoteCategories = repo.pantryCategoriesForQuery(name = null)&#10;    }&#10;&#10;    // When query changes, refresh categories and pantry items from backend&#10;    LaunchedEffect(query) {&#10;        runCatching { repo.syncPantry(search = query.ifBlank { null }, categoryId = selectedCategoryId) }&#10;        remoteCategories = runCatching { repo.pantryCategoriesForQuery(name = query.ifBlank { null }) }.getOrDefault(emptyList())&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = { TopAppBar(title = { Text(&quot;Alacena&quot;) }) },&#10;        snackbarHost = { SnackbarHost(snack) },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = { showAdd = true }) { Icon(Icons.Default.Add, contentDescription = null) }&#10;        }&#10;    ) { padding -&gt;&#10;        Column(Modifier.fillMaxSize().padding(padding).padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;            OutlinedTextField(&#10;                value = query,&#10;                onValueChange = { query = it },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                label = { Text(&quot;Buscar&quot;) },&#10;                singleLine = true&#10;            )&#10;            LazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {&#10;                item {&#10;                    FilterChip(selected = selectedCategoryId == null, onClick = {&#10;                        selectedCategoryId = null&#10;                        // Refresh items from backend without category filter&#10;                        scope.launch {&#10;                            runCatching { repo.syncPantry(search = query.ifBlank { null }, categoryId = null) }&#10;                            remoteCategories = runCatching { repo.pantryCategoriesForQuery(name = query.ifBlank { null }) }.getOrDefault(emptyList())&#10;                        }&#10;                    }, label = { Text(&quot;Todas&quot;) })&#10;                }&#10;                items(remoteCategories.size) { i -&gt;&#10;                    val c = remoteCategories[i]&#10;                    FilterChip(selected = selectedCategoryId == (c.id ?: -1L), onClick = {&#10;                        selectedCategoryId = c.id&#10;                        scope.launch {&#10;                            runCatching { repo.syncPantry(search = query.ifBlank { null }, categoryId = c.id) }&#10;                            // Categories may change with search text but not with the category itself; keep them&#10;                        }&#10;                    }, label = { Text(c.name) })&#10;                }&#10;            }&#10;&#10;            Divider()&#10;&#10;            val productById = remember(products) { products.associateBy { it.id } }&#10;            // Now pantryItems ya vienen filtrados por backend (query y categoryId), así que acá solo mapeamos a UI&#10;            val filteredPantry = pantryItems&#10;&#10;            LazyColumn(Modifier.fillMaxWidth().weight(1f), contentPadding = PaddingValues(bottom = 88.dp)) {&#10;                if (filteredPantry.isEmpty()) {&#10;                    item { Text(&quot;Sin productos en la alacena&quot;, style = MaterialTheme.typography.bodyMedium) }&#10;                } else {&#10;                    items(filteredPantry.size) { idx -&gt;&#10;                        val pi = filteredPantry[idx]&#10;                        val p = productById[pi.productId]&#10;                        PantryRow(&#10;                            name = p?.name ?: &quot;Producto&quot;,&#10;                            unit = p?.unit?.ifBlank { &quot;u&quot; } ?: &quot;u&quot;,&#10;                            quantity = pi.quantity,&#10;                            onInc = {&#10;                                scope.launch {&#10;                                    repo.updatePantryItem(pi.id, pi.quantity + 1)&#10;                                }&#10;                            },&#10;                            onDec = {&#10;                                if (pi.quantity &gt; 1) scope.launch {&#10;                                    repo.updatePantryItem(pi.id, pi.quantity - 1)&#10;                                }&#10;                            },&#10;                            onDelete = { scope.launch { repo.deletePantryItem(pi.id) } }&#10;                        )&#10;                        Divider()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAdd) {&#10;        val categoryById: Map&lt;Long, Category&gt; = remember(categories) { categories.associateBy { it.id } }&#10;        AddPantryItemDialog(&#10;            products = products,&#10;            categories = categories.map { it.name },&#10;            categoryNameFor = { pid -&gt;&#10;                val prod = products.firstOrNull { it.id == pid }&#10;                prod?.categoryId?.let { cid -&gt; categoryById[cid]?.name }&#10;            },&#10;            onDismiss = { showAdd = false },&#10;            onAdd = { productId, name, price, unit, categoryName -&gt;&#10;                scope.launch {&#10;                    try {&#10;                        val finalProductId = if (productId != null) {&#10;                            val existing = products.firstOrNull { it.id == productId }&#10;                            if (!name.isNullOrBlank() || price != null || !unit.isNullOrBlank() || !categoryName.isNullOrBlank()) {&#10;                                val catId = categoryName?.takeIf { it.isNotBlank() }?.let { repo.createOrFindCategoryByName(it) } ?: existing?.categoryId&#10;                                repo.updateProductRemote(productId, name ?: existing?.name ?: &quot;&quot;, price ?: existing?.price ?: 0.0, unit ?: existing?.unit ?: &quot;u&quot;, catId)&#10;                            }&#10;                            productId&#10;                        } else {&#10;                            val catId = categoryName?.takeIf { it.isNotBlank() }?.let { repo.createOrFindCategoryByName(it) }&#10;                            repo.createProductRemote(name!!.trim(), price ?: 0.0, unit ?: &quot;u&quot;, catId)&#10;                        }&#10;                        // Use addOrIncrement to avoid 409 and crashes if already exists&#10;                        repo.addOrIncrementPantryItem(finalProductId, addQuantity = 1, unit = unit ?: &quot;u&quot;)&#10;                        runCatching { repo.syncPantry() }&#10;                        showAdd = false&#10;                    } catch (t: Throwable) {&#10;                        snack.showSnackbar(t.message ?: &quot;No se pudo agregar el producto a la alacena&quot;)&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun AddPantryItemDialog(&#10;    products: List&lt;Product&gt;,&#10;    categories: List&lt;String&gt;,&#10;    categoryNameFor: (Long) -&gt; String?,&#10;    onDismiss: () -&gt; Unit,&#10;    onAdd: (productId: Long?, name: String?, price: Double?, unit: String?, categoryName: String?) -&gt; Unit&#10;) {&#10;    var name by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var selectedId by rememberSaveable { mutableStateOf&lt;Long?&gt;(null) }&#10;    var priceText by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var unit by rememberSaveable { mutableStateOf(&quot;u&quot;) }&#10;    var category by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    var busy by remember { mutableStateOf(false) }&#10;&#10;    fun prefill(product: Product) {&#10;        name = product.name&#10;        priceText = if (product.price != 0.0) product.price.toString() else &quot;&quot;&#10;        unit = product.unit.ifBlank { &quot;u&quot; }&#10;        category = categoryNameFor(product.id) ?: &quot;&quot;&#10;    }&#10;&#10;    val suggestions = remember(name, products) {&#10;        val q = name.trim()&#10;        if (q.isBlank()) emptyList() else products.filter { it.name.contains(q, ignoreCase = true) }.take(8)&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { if (!busy) onDismiss() },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                busy = true&#10;                val price = priceText.toDoubleOrNull()&#10;                onAdd(selectedId, if (selectedId == null) name else name.takeIf { it.isNotBlank() }, price, unit, category.ifBlank { null })&#10;                busy = false&#10;            }, enabled = !busy &amp;&amp; (selectedId != null || name.isNotBlank())) { Text(&quot;Agregar&quot;) }&#10;        },&#10;        dismissButton = { TextButton(onClick = { if (!busy) onDismiss() }) { Text(&quot;Cancelar&quot;) } },&#10;        title = { Text(&quot;Agregar a la alacena&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(&#10;                    value = name,&#10;                    onValueChange = { v -&gt;&#10;                        name = v&#10;                        val match = products.firstOrNull { it.name.equals(v, ignoreCase = true) }&#10;                        selectedId = match?.id&#10;                        if (match != null) prefill(match)&#10;                    },&#10;                    label = { Text(&quot;Producto&quot;) },&#10;                    singleLine = true&#10;                )&#10;                if (suggestions.isNotEmpty()) {&#10;                    suggestions.forEach { s -&gt;&#10;                        TextButton(onClick = { selectedId = s.id; prefill(s); name = s.name }) { Text(s.name) }&#10;                    }&#10;                }&#10;                OutlinedTextField(value = priceText, onValueChange = { priceText = it.filter { ch -&gt; ch.isDigit() || ch == '.' } }, label = { Text(&quot;Precio (opcional)&quot;) }, singleLine = true)&#10;                OutlinedTextField(value = unit, onValueChange = { unit = it }, label = { Text(&quot;Unidad&quot;) }, singleLine = true)&#10;                OutlinedTextField(value = category, onValueChange = { category = it }, label = { Text(&quot;Categoría (opcional)&quot;) }, singleLine = true)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun PantryRow(&#10;    name: String,&#10;    unit: String,&#10;    quantity: Int,&#10;    onInc: () -&gt; Unit,&#10;    onDec: () -&gt; Unit,&#10;    onDelete: () -&gt; Unit&#10;) {&#10;    ListItem(&#10;        headlineContent = { Text(name) },&#10;        supportingContent = { Text(&quot;$unit x $quantity&quot;) },&#10;        trailingContent = {&#10;            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                TextButton(onClick = onDec) { Text(&quot;-&quot;) }&#10;                Text(quantity.toString())&#10;                TextButton(onClick = onInc) { Text(&quot;+&quot;) }&#10;                IconButton(onClick = onDelete) { Icon(Icons.Default.Delete, contentDescription = null) }&#10;            }&#10;        }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>